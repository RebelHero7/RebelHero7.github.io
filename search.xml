<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Spring解决循环依赖源码解析</title>
      <link href="2020/07/23/spring-jie-jue-xun-huan-yi-lai-yuan-ma-jie-xi/"/>
      <url>2020/07/23/spring-jie-jue-xun-huan-yi-lai-yuan-ma-jie-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="写在前面的话"><a href="#写在前面的话" class="headerlink" title="写在前面的话"></a>写在前面的话</h1><p>循环依赖是啥我就不说了，具体就讲怎么解决的，我觉得可以一句话概括，<strong>在Bean还没初始化前，使用早期引用！</strong>推荐先看一下我的上篇文章<a href="https://blog.csdn.net/RebelHero/article/details/107457172">Spring IOC 容器源码简单分析</a>了解如何获取bean的。</p><h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><p>首先进入getBean 进入doGetBean：</p><pre><code class="highlight java"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(<span class="keyword">final</span> String name, <span class="meta">@Nullable</span> <span class="keyword">final</span> Class&lt;T&gt; requiredType,</span></span><span class="function"><span class="params"><span class="meta">@Nullable</span> <span class="keyword">final</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span> <span class="keyword">throws</span> BeansException </span>&#123;<span class="keyword">final</span> String beanName = transformedBeanName(name);Object bean;<span class="comment">// 获取 bean 实例！！！！重点。</span>Object sharedInstance = getSingleton(beanName);<span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;<span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;logger.trace(<span class="string">&quot;Returning eagerly cached instance of singleton bean &#x27;&quot;</span> + beanName +<span class="string">&quot;&#x27; that is not fully initialized yet - a consequence of a circular reference&quot;</span>);&#125;<span class="keyword">else</span> &#123;logger.trace(<span class="string">&quot;Returning cached instance of singleton bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);&#125;&#125;<span class="comment">// 如果是普通的Bean则直接返回，如果是FactoryBean则返回其创建的Bean。</span>bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="keyword">null</span>);&#125;<span class="comment">// 省略下面代码。</span>&#125;</code></pre><p>可以看见getSingleton使用了获取bean实例，这个方法是<strong>解决循环依赖的核心</strong>，那么点进看：</p><pre><code class="highlight java"><span class="function"><span class="keyword">protected</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, <span class="keyword">boolean</span> allowEarlyReference)</span> </span>&#123;<span class="comment">// 获取已经初始化好的bean实例。</span>Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);<span class="comment">// 如果不存在，同时这个bean正在创建中！</span><span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;<span class="comment">// 加个锁。</span><span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;<span class="comment">// 获取bean的早期引用。</span>singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);<span class="comment">// 如果早期引用也不存在，同时，允许早期引用。</span><span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; allowEarlyReference) &#123;<span class="comment">// 获取bean工厂。</span>ObjectFactory&lt;?&gt; singletonFactory = <span class="keyword">this</span>.singletonFactories.get(beanName);<span class="keyword">if</span> (singletonFactory != <span class="keyword">null</span>) &#123;<span class="comment">// 从工厂中获取还未初始化好的bean。</span>singletonObject = singletonFactory.getObject();<span class="comment">// 放入早期引用缓存中，同时从 singletonFactories移除。</span><span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);<span class="keyword">this</span>.singletonFactories.remove(beanName);&#125;&#125;&#125;&#125;<span class="keyword">return</span> singletonObject;&#125;</code></pre><p>可能不了解的都会挺云里雾里的，先解释一下其中三个变量吧。</p><p>先看看它们的定义：</p><pre><code class="highlight java"><span class="comment">/** Cache of singleton objects: bean name to bean instance. */</span><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">256</span>);<span class="comment">/** Cache of singleton factories: bean name to ObjectFactory. */</span><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);<span class="comment">/** Cache of early singleton objects: bean name to bean instance. */</span><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</code></pre><table><thead><tr><th>名称</th><th>作用</th></tr></thead><tbody><tr><td>singletonObjects</td><td>bean名称和bean实例的缓存，是已经完全初始化好了的，可以直接用的。</td></tr><tr><td>singletonFactories</td><td>bean名称和bean工厂的缓存，存放 bean 工厂对象。</td></tr><tr><td>earlySingletonObjects</td><td>bean名称和bean原始对象的缓存（尚未初始化好的，没填充属性的），<strong>解决循环依赖。</strong></td></tr><tr><td>所以说，上面的流程就是：</td><td></td></tr></tbody></table><ol><li>先获取已经实例化好的bean，有就直接走，没有就下一步。</li><li>获取这个bean的早期引用，有就直接走，没有就下一步。</li><li>早期引用都没有，就获取bean工厂，有就获取其中还未初始化好的bean，放入早期引用的earlySingletonObjects 中，没有就真没有，返回null咯，有就返回这个尚未初始化好的bean（此时也已经在早期引用的map中）。</li></ol><p>那么问题来了， 这个singletonFactories中的singletonFactory 及其尚未初始化好的bean是哪来的呢。</p><p>把目光切回doGetBean，再往下看：</p><pre><code class="highlight java"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(<span class="keyword">final</span> String name, <span class="meta">@Nullable</span> <span class="keyword">final</span> Class&lt;T&gt; requiredType,</span></span><span class="function"><span class="params"><span class="meta">@Nullable</span> <span class="keyword">final</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span> <span class="keyword">throws</span> BeansException </span>&#123;<span class="keyword">final</span> String beanName = transformedBeanName(name);Object bean;Object sharedInstance = getSingleton(beanName);<span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;<span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;logger.trace(<span class="string">&quot;Returning eagerly cached instance of singleton bean &#x27;&quot;</span> + beanName +<span class="string">&quot;&#x27; that is not fully initialized yet - a consequence of a circular reference&quot;</span>);&#125;<span class="keyword">else</span> &#123;logger.trace(<span class="string">&quot;Returning cached instance of singleton bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);&#125;&#125;bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="keyword">null</span>);&#125;....<span class="comment">// Create bean instance.</span><span class="keyword">if</span> (mbd.isSingleton()) &#123;<span class="comment">// 看这里！！</span>sharedInstance = getSingleton(beanName, () -&gt; &#123;<span class="keyword">try</span> &#123;<span class="comment">// 创建 bean 实例，这时返回的 bean 是完全实例化好的。</span><span class="keyword">return</span> createBean(beanName, mbd, args);&#125;<span class="keyword">catch</span> (BeansException ex) &#123;destroySingleton(beanName);<span class="keyword">throw</span> ex;&#125;&#125;);bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);&#125;&#125;</code></pre><p>那么我们再点进去看createaBean：</p><pre><code class="highlight java"><span class="function"><span class="keyword">protected</span> Object <span class="title">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span><span class="function"><span class="keyword">throws</span> BeanCreationException </span>&#123;.........<span class="keyword">try</span> &#123;<span class="comment">// 这里是创建！！</span>Object beanInstance = doCreateBean(beanName, mbdToUse, args);<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;logger.trace(<span class="string">&quot;Finished creating instance of bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);&#125;<span class="keyword">return</span> beanInstance;&#125;<span class="comment">// 省略catch。</span>&#125;</code></pre><p>再继续看，这个doCreateBean方法！</p><pre><code class="highlight java"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> <span class="meta">@Nullable</span> Object[] args)</span></span><span class="function"><span class="keyword">throws</span> BeanCreationException </span>&#123;<span class="comment">// ！！ 创建 bean 对象，同时将 bean 对象包裹在 BeanWrapper 中返回。</span>BeanWrapper instanceWrapper = <span class="keyword">null</span>;...<span class="comment">// 获取包裹在其中的bean，此时还是尚未填充属性的！</span><span class="keyword">final</span> Object bean = instanceWrapper.getWrappedInstance();<span class="comment">// earlySingletonExposure 这个变量就是用来解决循环依赖的。</span><span class="comment">// 判断很明显，是否是单例，是否允许循环依赖，是否这个单例正在创建中。</span><span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp;isSingletonCurrentlyInCreation(beanName));<span class="keyword">if</span> (earlySingletonExposure) &#123;<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;logger.trace(<span class="string">&quot;Eagerly caching bean &#x27;&quot;</span> + beanName +<span class="string">&quot;&#x27; to allow for resolving potential circular references&quot;</span>);&#125;<span class="comment">// 重头戏重头戏！！添加 bean 工厂到 singletonFactories 中。</span>addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));&#125;Object exposedObject = bean;<span class="keyword">try</span> &#123;<span class="comment">// 在这里才开始填充属性！！</span>populateBean(beanName, mbd, instanceWrapper);exposedObject = initializeBean(beanName, exposedObject, mbd);&#125;...<span class="keyword">return</span> exposedObject;&#125;</code></pre><p>可以看见上面的addSingletonFactory就是关键。看一下：</p><pre><code class="highlight java"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addSingletonFactory</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> </span>&#123;Assert.notNull(singletonFactory, <span class="string">&quot;Singleton factory must not be null&quot;</span>);<span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;<span class="comment">// 如果该bean尚未实例化好。</span><span class="keyword">if</span> (!<span class="keyword">this</span>.singletonObjects.containsKey(beanName)) &#123;<span class="keyword">this</span>.singletonFactories.put(beanName, singletonFactory);<span class="keyword">this</span>.earlySingletonObjects.remove(beanName);<span class="keyword">this</span>.registeredSingletons.add(beanName);&#125;&#125;&#125;</code></pre><p>喏，就是此处放进的，这个时候，bean已经创建出来了，但是还未填充属性！它就是bean的早期引用。</p><p>结合实例讲解一下：</p><ol><li>在新建 A的时候，依赖了B，那么会在populateBean这个方法中会去getBean去获取B的实例。</li><li>但是因为B不存在，那么B也按A之前的流程走一遍，同时也会卡在populateBean中getBean获取A的实例。</li><li>然后我们知道，A的原始bean，是已经放在了singletonFactories中的！那么在BgetBean获取A的实例时，Object sharedInstance = getSingleton(beanName);这个方法，返回的就不是null了，而是一个A的早期引用，因此B得以顺利的走下去，完成初始化。这时，A也可以继续走下去完成初始化了，同时，因为A和A的早期引用的是指向同一个对象的，也就是说，A完成初始化时，B中依赖的A也是已经初始化好了的A了！</li></ol><p>按理说是要有个总结的，但是文章已经讲的很清楚了，那就不总结啦。拜了个拜。</p><p><strong>最后，谢谢观看。本人才疏学浅，如有错误之处，欢迎指正，共同进步。</strong></p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> Spring源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring IOC 容器源码简单分析</title>
      <link href="2020/07/22/spring-ioc-rong-qi-yuan-ma-jian-dan-fen-xi/"/>
      <url>2020/07/22/spring-ioc-rong-qi-yuan-ma-jian-dan-fen-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="写在前面的话："><a href="#写在前面的话：" class="headerlink" title="写在前面的话："></a>写在前面的话：</h1><p>首先，这块代码无疑是难以理解的，之前好几次准备认真看看到一半被绕来绕去绕晕了，然后就放弃了。最近还是决定拾起来看了，但不同以往，这次我是备而来的！看了《Spring 揭密》这本书，这本书比较老了，但是Spring 核心这么多年也没变化太多，看的是一个这本书给的一个思路。同时特地跟着<a href="https://github.com/code4craft/tiny-spring">tiny-spring</a>这个项目走了遍它的逻辑，有了这个基础去理解Spring Ioc这块的源码起码有点底子，非常感谢这个项目的作者。</p><p>其次，我觉得Spring代码很繁杂，很多方法没必要刨根问底，不该本末倒置太纠结细节，<strong>而应去了解关键方法，串成一个链，着重的应该是它的思路，及其运行过程</strong>，因此很多方法会略过介绍的。而且标题也写了是简单分析，因此不会很详细的！</p><h1 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h1><p>简单介绍一下需要了解的知识吧：</p><p>BeanFactory：基础类型IoC容器，一个生产Bean的工厂。没有特殊指定时，<strong>默认采用延迟初始化（lazy-load）</strong>。当需要容器中的某个Bean时，才对该Bean进行初始化以及依赖注入操作。</p><p>ApplicationContext：在BeanFactory的基础上构建，拥有BeanFactory的所有支持，以及事件发布、国际化信息支持等，<strong>默认容器启动时全部初始化并绑定完成</strong>。</p><p>BeanDefinition：我们熟知的Bean，在Spring中肯定不是简单的set、get，保存的格式是BeanDefinition，会注册到Spring的BeanDefinitionRegistry。BeanDefinition包含了Bean 信息，如该 Bean 类名、是否是单例的、依赖了哪些 Bean 等。</p><p>BeanFactoryPostProcessor：允许我们在容器实例化相应对象之前，对注册到容器的BeanDefinition所保存的信息做相应的修改。这就相当于在容器实现的第一阶段最后加入一道工序，让我们对最终的BeanDefinition做一些额外的操作，比如修改其中bean定义的某些属性，为bean定义增加其他信息等。</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>从这个地方开启源码之路！</p><pre><code class="highlight java"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;    ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;classpath:application.xml&quot;</span>);&#125;</code></pre><p>点进ClassPathXmlApplicationContext构造方法。</p><pre><code class="highlight java"><span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(String... configLocations)</span> <span class="keyword">throws</span> BeansException </span>&#123;<span class="keyword">this</span>(configLocations, <span class="keyword">true</span>, <span class="keyword">null</span>);&#125;...<span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(</span></span><span class="function"><span class="params">String[] configLocations, <span class="keyword">boolean</span> refresh, <span class="meta">@Nullable</span> ApplicationContext parent)</span></span><span class="function"><span class="keyword">throws</span> BeansException </span>&#123;<span class="keyword">super</span>(parent);<span class="comment">// 将所给路径的文件，处理成配置文件数组。</span>setConfigLocations(configLocations);<span class="keyword">if</span> (refresh) &#123;refresh();&#125;&#125;</code></pre><p>那核心必须是refresh()这个方法啊，点进去看。</p><h2 id="refresh"><a href="#refresh" class="headerlink" title="refresh"></a>refresh</h2><pre><code class="highlight java"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;<span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;<span class="comment">// 准备刷新，设置启动日期和active标志以及文件中的占位符。</span>prepareRefresh();<span class="comment">// ！！重要，这个方法一路走下去就会解析xml文件为BeanDefinition, 同时注册进框架。</span><span class="comment">// 当然，这个时候还没有初始化！！！！，只是解析好，并注册进了。</span>ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();<span class="comment">// 配置工厂，如类加载器和BeanPostProcessor。</span>prepareBeanFactory(beanFactory);<span class="keyword">try</span> &#123;<span class="comment">// 在所有BeanDefinition已经加载完毕，但是还没有实例化bean。</span><span class="comment">// 允许在某些ApplicationContext实现中注册特殊的BeanPostProcessors。 </span>postProcessBeanFactory(beanFactory);<span class="comment">// Invoke factory processors registered as beans in the context.</span>invokeBeanFactoryPostProcessors(beanFactory);<span class="comment">// Register bean processors that intercept bean creation.</span>registerBeanPostProcessors(beanFactory);<span class="comment">// Initialize message source for this context.</span>initMessageSource();<span class="comment">// Initialize event multicaster for this context.</span>initApplicationEventMulticaster();<span class="comment">// Initialize other special beans in specific context subclasses.</span>onRefresh();<span class="comment">// Check for listener beans and register them.</span>registerListeners();<span class="comment">// 实例化所有剩余的（非延迟初始化）单例！！！也是重点！！</span>finishBeanFactoryInitialization(beanFactory);<span class="comment">// Last step: publish corresponding event.</span>finishRefresh();&#125;<span class="keyword">catch</span> (BeansException ex) &#123;<span class="keyword">if</span> (logger.isWarnEnabled()) &#123;logger.warn(<span class="string">&quot;Exception encountered during context initialization - &quot;</span> +<span class="string">&quot;cancelling refresh attempt: &quot;</span> + ex);&#125;<span class="comment">// Destroy already created singletons to avoid dangling resources.</span>destroyBeans();<span class="comment">// Reset &#x27;active&#x27; flag.</span>cancelRefresh(ex);<span class="comment">// Propagate exception to caller.</span><span class="keyword">throw</span> ex;&#125;<span class="keyword">finally</span> &#123;<span class="comment">// Reset common introspection caches in Spring&#x27;s core, since we</span><span class="comment">// might not ever need metadata for singleton beans anymore...</span>resetCommonCaches();&#125;&#125;&#125;</code></pre><h2 id="将xml转换为BeanDefinition"><a href="#将xml转换为BeanDefinition" class="headerlink" title="将xml转换为BeanDefinition"></a>将xml转换为BeanDefinition</h2><p>这个方法是很流程的东西，最核心的就是obtainFreshBeanFactory()方法，下面看一下该方法：</p><pre><code class="highlight java"><span class="function"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title">obtainFreshBeanFactory</span><span class="params">()</span> </span>&#123;refreshBeanFactory();<span class="keyword">return</span> getBeanFactory();&#125;</code></pre><p>该方法里就只有两个方法， 继续点进去看，先看refreshBeanFactory():</p><pre><code class="highlight java"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;<span class="comment">// 判断是否已经有了BeanFactory，如果已经有了，则销毁所有的beans, 关闭已有的BeanFactory</span><span class="keyword">if</span> (hasBeanFactory()) &#123;destroyBeans();closeBeanFactory();&#125;<span class="keyword">try</span> &#123;<span class="comment">// 初始化一个 DefaultListableBeanFactory，这个BeanFactory基本继承了所有的BeanFactory。</span>DefaultListableBeanFactory beanFactory = createBeanFactory();<span class="comment">// 设置BeanFactory的序列化。</span>beanFactory.setSerializationId(getId());<span class="comment">// 设置 BeanFactory 是否允许 Bean 覆盖、是否允许循环引用。</span>customizeBeanFactory(beanFactory);<span class="comment">// 加载BeanDefinition。</span>loadBeanDefinitions(beanFactory);<span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanFactoryMonitor) &#123;<span class="keyword">this</span>.beanFactory = beanFactory;&#125;&#125;<span class="keyword">catch</span> (IOException ex) &#123;<span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">&quot;I/O error parsing bean definition source for &quot;</span> + getDisplayName(), ex);&#125;&#125;</code></pre><p>为啥说这个BeanFactory是最牛的呢，请看图：<br><img src="https://img-blog.csdnimg.cn/20200720143859691.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1JlYmVsSGVybw==,size_16,color_FFFFFF,t_70" alt="DefaultListableBeanFactory"><br>上个方法核心很明显是loadBeanDefinitions，加载BeanDefinition。下面看下这个。</p><h3 id="loadBeanDefinitions-加载BeanDefinition"><a href="#loadBeanDefinitions-加载BeanDefinition" class="headerlink" title="loadBeanDefinitions 加载BeanDefinition"></a>loadBeanDefinitions 加载BeanDefinition</h3><pre><code class="highlight java"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;<span class="comment">// 为该BeanFactory创建一个新的XmlBeanDefinitionReader。</span>XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);<span class="comment">// 设置一些配置，因为不是核心，没仔细看。</span>beanDefinitionReader.setEnvironment(<span class="keyword">this</span>.getEnvironment());beanDefinitionReader.setResourceLoader(<span class="keyword">this</span>);beanDefinitionReader.setEntityResolver(<span class="keyword">new</span> ResourceEntityResolver(<span class="keyword">this</span>));<span class="comment">// 初始化 BeanDefinitionReader，也不重要。</span>initBeanDefinitionReader(beanDefinitionReader);<span class="comment">// 核心是这个，加载BeanDefinition！！</span>loadBeanDefinitions(beanDefinitionReader);&#125;</code></pre><p>看loadBeanDefinitions方法：</p><pre><code class="highlight java"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(XmlBeanDefinitionReader reader)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;Resource[] configResources = getConfigResources();<span class="keyword">if</span> (configResources != <span class="keyword">null</span>) &#123;<span class="comment">//  看这儿 &lt;1&gt;。</span>reader.loadBeanDefinitions(configResources);&#125;String[] configLocations = getConfigLocations();<span class="keyword">if</span> (configLocations != <span class="keyword">null</span>) &#123;<span class="comment">// 这个看着看着还是会回到上面的loadBeanDefinitions的。</span>reader.loadBeanDefinitions(configLocations);&#125;&#125;<span class="comment">// 对应的&lt;1&gt;的loadBeanDefinitions</span><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(Resource... resources)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;Assert.notNull(resources, <span class="string">&quot;Resource array must not be null&quot;</span>);<span class="comment">// 表示加载了多少的BeanDefinition。</span><span class="keyword">int</span> count = <span class="number">0</span>;<span class="keyword">for</span> (Resource resource : resources) &#123;<span class="comment">// 加载BeanDefinition，有三种，看XmlBeanDefinitionReader的就行。</span>count += loadBeanDefinitions(resource);&#125;<span class="keyword">return</span> count;&#125;<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;<span class="keyword">return</span> loadBeanDefinitions(<span class="keyword">new</span> EncodedResource(resource));&#125;<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(EncodedResource encodedResource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;Assert.notNull(encodedResource, <span class="string">&quot;EncodedResource must not be null&quot;</span>);<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;logger.trace(<span class="string">&quot;Loading XML bean definitions from &quot;</span> + encodedResource);&#125;Set&lt;EncodedResource&gt; currentResources = <span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.get();<span class="keyword">if</span> (currentResources == <span class="keyword">null</span>) &#123;currentResources = <span class="keyword">new</span> HashSet&lt;&gt;(<span class="number">4</span>);<span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.set(currentResources);&#125;<span class="keyword">if</span> (!currentResources.add(encodedResource)) &#123;<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(<span class="string">&quot;Detected cyclic loading of &quot;</span> + encodedResource + <span class="string">&quot; - check your import definitions!&quot;</span>);&#125;<span class="keyword">try</span> &#123;<span class="comment">// 读取这个文件流。</span>InputStream inputStream = encodedResource.getResource().getInputStream();<span class="keyword">try</span> &#123;InputSource inputSource = <span class="keyword">new</span> InputSource(inputStream);<span class="keyword">if</span> (encodedResource.getEncoding() != <span class="keyword">null</span>) &#123;inputSource.setEncoding(encodedResource.getEncoding());&#125;<span class="comment">// 我发现Spring中所有的doXxx才是真正的加载，因此绕了半天绕到这里才是真正开始加载。</span><span class="keyword">return</span> doLoadBeanDefinitions(inputSource, encodedResource.getResource());&#125;<span class="keyword">finally</span> &#123;inputStream.close();&#125;&#125;<span class="keyword">catch</span> (IOException ex) &#123;<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(<span class="string">&quot;IOException parsing XML document from &quot;</span> + encodedResource.getResource(), ex);&#125;<span class="keyword">finally</span> &#123;currentResources.remove(encodedResource);<span class="keyword">if</span> (currentResources.isEmpty()) &#123;<span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.remove();&#125;&#125;&#125;<span class="comment">/**</span><span class="comment">* 这个方法好多的catch，我给略过了。</span><span class="comment">*/</span><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doLoadBeanDefinitions</span><span class="params">(InputSource inputSource, Resource resource)</span></span><span class="function"><span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;<span class="keyword">try</span> &#123;<span class="comment">// 将xml文件转成一个Document对象。</span>Document doc = doLoadDocument(inputSource, resource);<span class="comment">// 注册BeanDefinition们。</span><span class="keyword">int</span> count = registerBeanDefinitions(doc, resource);<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;logger.debug(<span class="string">&quot;Loaded &quot;</span> + count + <span class="string">&quot; bean definitions from &quot;</span> + resource);&#125;<span class="keyword">return</span> count;&#125;<span class="comment">// 一堆catch。</span>&#125;<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();<span class="comment">// 在注册前的BeanDefinition数量。</span><span class="keyword">int</span> countBefore = getRegistry().getBeanDefinitionCount();<span class="comment">// 注册。</span>documentReader.registerBeanDefinitions(doc, createReaderContext(resource));<span class="comment">// 现有注册数量 - 之前的注册数量 = 该次注册数量（在说废话...）。</span><span class="keyword">return</span> getRegistry().getBeanDefinitionCount() - countBefore;&#125;<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, XmlReaderContext readerContext)</span> </span>&#123;<span class="keyword">this</span>.readerContext = readerContext;<span class="comment">// 我就说吧，doXxx才是干实事的！</span>doRegisterBeanDefinitions(doc.getDocumentElement());&#125;</code></pre><p>这些都是一连贯的，因此我们来看看干实事的doRegisterBeanDefinitions！</p><h3 id="doRegisterBeanDefinitions-注册BeanDefinition"><a href="#doRegisterBeanDefinitions-注册BeanDefinition" class="headerlink" title="doRegisterBeanDefinitions 注册BeanDefinition"></a>doRegisterBeanDefinitions 注册BeanDefinition</h3><pre><code class="highlight java"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegisterBeanDefinitions</span><span class="params">(Element root)</span> </span>&#123;<span class="comment">// 瞧瞧人家这名字，BeanDefinition转换代表，一看就与众不同。</span>BeanDefinitionParserDelegate parent = <span class="keyword">this</span>.delegate;<span class="keyword">this</span>.delegate = createDelegate(getReaderContext(), root, parent);<span class="comment">// 判断是不是默认的NameSpace -&gt; http://www.springframework.org/schema/beans</span><span class="keyword">if</span> (<span class="keyword">this</span>.delegate.isDefaultNamespace(root)) &#123;<span class="comment">// 判断其profile，dev、test还是prod，如果不是当前环境定义的就过过过。</span>String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);<span class="keyword">if</span> (StringUtils.hasText(profileSpec)) &#123;String[] specifiedProfiles = StringUtils.tokenizeToStringArray(profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);<span class="comment">// We cannot use Profiles.of(...) since profile expressions are not supported</span><span class="comment">// in XML config. See SPR-12458 for details.</span><span class="keyword">if</span> (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123;<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;logger.debug(<span class="string">&quot;Skipped XML bean definition file due to specified profiles [&quot;</span> + profileSpec +<span class="string">&quot;] not matching: &quot;</span> + getReaderContext().getResource());&#125;<span class="keyword">return</span>;&#125;&#125;&#125;preProcessXml(root);<span class="comment">// 重点。</span>parseBeanDefinitions(root, <span class="keyword">this</span>.delegate);postProcessXml(root);<span class="keyword">this</span>.delegate = parent;&#125;<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">parseBeanDefinitions</span><span class="params">(Element root, BeanDefinitionParserDelegate delegate)</span> </span>&#123;<span class="keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;NodeList nl = root.getChildNodes();<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;Node node = nl.item(i);<span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;Element ele = (Element) node;<span class="keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;<span class="comment">// 点进去可以看见。</span><span class="comment">// 解析默认的Elemtment, 就以下四种，import, alias, bean, beans。</span>parseDefaultElement(ele, delegate);&#125;<span class="keyword">else</span> &#123;<span class="comment">// 那除了上面四种，就是其他的咯。</span>delegate.parseCustomElement(ele);&#125;&#125;&#125;&#125;<span class="keyword">else</span> &#123;delegate.parseCustomElement(root);&#125;&#125;</code></pre><p>其他不关注了，就看怎么解析bean。点进parseDefaultElement再进processBeanDefinition。看processBeanDefinition：</p><h3 id="processBeanDefinition-解析为BeanDefinition"><a href="#processBeanDefinition-解析为BeanDefinition" class="headerlink" title="processBeanDefinition 解析为BeanDefinition"></a>processBeanDefinition 解析为BeanDefinition</h3><pre><code class="highlight java"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processBeanDefinition</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;<span class="comment">// 具体就不进去描述了，感兴趣的可以自己去看.</span><span class="comment">// 反正总的来说就是解析了&lt;bean&gt;为一个BeanDefinitionHolder</span>BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);<span class="keyword">if</span> (bdHolder != <span class="keyword">null</span>) &#123;bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);<span class="keyword">try</span> &#123;<span class="comment">// 注册咯。</span>BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());&#125;<span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;getReaderContext().error(<span class="string">&quot;Failed to register bean definition with name &#x27;&quot;</span> +bdHolder.getBeanName() + <span class="string">&quot;&#x27;&quot;</span>, ele, ex);&#125;<span class="comment">// 发送注册事件。</span>getReaderContext().fireComponentRegistered(<span class="keyword">new</span> BeanComponentDefinition(bdHolder));&#125;&#125;<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(</span></span><span class="function"><span class="params">BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span></span><span class="function"><span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;<span class="comment">// 获取bean名称。</span>String beanName = definitionHolder.getBeanName();<span class="comment">// 然后注册进Bean，看下面我引的方法解读。</span>registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());<span class="comment">// 有别名的话，就注册别名。点进去一步步看能看出，是aliasMap, 其中key是alias，value是beanName。</span>String[] aliases = definitionHolder.getAliases();<span class="keyword">if</span> (aliases != <span class="keyword">null</span>) &#123;<span class="keyword">for</span> (String alias : aliases) &#123;registry.registerAlias(beanName, alias);&#125;&#125;&#125;<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span><span class="function"><span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;Assert.hasText(beanName, <span class="string">&quot;Bean name must not be empty&quot;</span>);Assert.notNull(beanDefinition, <span class="string">&quot;BeanDefinition must not be null&quot;</span>);<span class="keyword">if</span> (beanDefinition <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;<span class="keyword">try</span> &#123;((AbstractBeanDefinition) beanDefinition).validate();&#125;<span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,<span class="string">&quot;Validation of bean definition failed&quot;</span>, ex);&#125;&#125;<span class="comment">// 判断改BeanName是否已经存在。</span>BeanDefinition existingDefinition = <span class="keyword">this</span>.beanDefinitionMap.get(beanName);<span class="comment">// 如果存在。</span><span class="keyword">if</span> (existingDefinition != <span class="keyword">null</span>) &#123;<span class="comment">// 且不允许覆盖，则，抛异常。</span><span class="keyword">if</span> (!isAllowBeanDefinitionOverriding()) &#123;<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionOverrideException(beanName, beanDefinition, existingDefinition);&#125;<span class="comment">// 重写用户自定义的 Bean。</span><span class="keyword">else</span> <span class="keyword">if</span> (existingDefinition.getRole() &lt; beanDefinition.getRole()) &#123;<span class="comment">// e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE</span><span class="keyword">if</span> (logger.isInfoEnabled()) &#123;logger.info(<span class="string">&quot;Overriding user-defined bean definition for bean &#x27;&quot;</span> + beanName +<span class="string">&quot;&#x27; with a framework-generated bean definition: replacing [&quot;</span> +existingDefinition + <span class="string">&quot;] with [&quot;</span> + beanDefinition + <span class="string">&quot;]&quot;</span>);&#125;&#125;<span class="comment">// 如果不是同一bean，则覆盖。</span><span class="keyword">else</span> <span class="keyword">if</span> (!beanDefinition.equals(existingDefinition)) &#123;<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;logger.debug(<span class="string">&quot;Overriding bean definition for bean &#x27;&quot;</span> + beanName +<span class="string">&quot;&#x27; with a different definition: replacing [&quot;</span> + existingDefinition +<span class="string">&quot;] with [&quot;</span> + beanDefinition + <span class="string">&quot;]&quot;</span>);&#125;&#125;<span class="comment">// 还是会覆盖。</span><span class="keyword">else</span> &#123;<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;logger.trace(<span class="string">&quot;Overriding bean definition for bean &#x27;&quot;</span> + beanName +<span class="string">&quot;&#x27; with an equivalent definition: replacing [&quot;</span> + existingDefinition +<span class="string">&quot;] with [&quot;</span> + beanDefinition + <span class="string">&quot;]&quot;</span>);&#125;&#125;<span class="comment">// 前面只是打日志，这才是实打实的覆盖。</span><span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);&#125;<span class="keyword">else</span> &#123;<span class="comment">// 判断是否已有bean初始化了。</span><span class="keyword">if</span> (hasBeanCreationStarted()) &#123;<span class="comment">// Cannot modify startup-time collection elements anymore (for stable iteration)</span><span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanDefinitionMap) &#123;<span class="comment">// 终于放进这个map！</span><span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);List&lt;String&gt; updatedDefinitions = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.beanDefinitionNames.size() + <span class="number">1</span>);updatedDefinitions.addAll(<span class="keyword">this</span>.beanDefinitionNames);updatedDefinitions.add(beanName);<span class="keyword">this</span>.beanDefinitionNames = updatedDefinitions;removeManualSingletonName(beanName);&#125;&#125;<span class="keyword">else</span> &#123;<span class="comment">// 没有就进这里，这里和上面差不多。</span><span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);<span class="keyword">this</span>.beanDefinitionNames.add(beanName);removeManualSingletonName(beanName);&#125;<span class="keyword">this</span>.frozenBeanDefinitionNames = <span class="keyword">null</span>;&#125;<span class="keyword">if</span> (existingDefinition != <span class="keyword">null</span> || containsSingleton(beanName)) &#123;resetBeanDefinition(beanName);&#125;&#125;</code></pre><p>至此，已经初始化了 Bean 容器，<bean>也转换为了BeanDefinition，也注册了各个 BeanDefinition 到注册中心了，但是还未初始化。以上就是<strong>obtainFreshBeanFactory方法</strong>一条链走下来的逻辑，简单梳理一下：<br><img src="https://img-blog.csdnimg.cn/20200721151116231.png" alt="获取BeanDefinition实例"><br><strong>下面再看refresh 中的 finishBeanFactoryInitialization方法，其中里面会初始化所有的Bean！</strong></p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><h3 id="finishBeanFactoryInitialization"><a href="#finishBeanFactoryInitialization" class="headerlink" title="finishBeanFactoryInitialization"></a>finishBeanFactoryInitialization</h3><pre><code class="highlight java"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;<span class="comment">// 初始化 conversionService 的 Bean。</span><span class="keyword">if</span> (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123;beanFactory.setConversionService(beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));&#125;<span class="comment">// 如果之前没有任何bean后处理器（例如PropertyPlaceholderConfigurer bean）之前进行过注册，</span><span class="comment">// 注册一个默认的嵌入式值解析器，主要用于注释属性值的解析。</span><span class="keyword">if</span> (!beanFactory.hasEmbeddedValueResolver()) &#123;beanFactory.addEmbeddedValueResolver(strVal -&gt; getEnvironment().resolvePlaceholders(strVal));&#125;<span class="comment">// Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.</span>String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, <span class="keyword">false</span>, <span class="keyword">false</span>);<span class="keyword">for</span> (String weaverAwareName : weaverAwareNames) &#123;getBean(weaverAwareName);&#125;<span class="comment">// Stop using the temporary ClassLoader for type matching.</span>beanFactory.setTempClassLoader(<span class="keyword">null</span>);<span class="comment">// Allow for caching all bean definition metadata, not expecting further changes.</span>beanFactory.freezeConfiguration();<span class="comment">// 开始初始化咯。</span>beanFactory.preInstantiateSingletons();&#125;</code></pre><p>下面看preInstantiateSingletons方法，进行初始化。</p><pre><code class="highlight java"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;logger.trace(<span class="string">&quot;Pre-instantiating singletons in &quot;</span> + <span class="keyword">this</span>);&#125;<span class="comment">// beanDefinitionNames是已经解析好的bean name.</span>List&lt;String&gt; beanNames = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.beanDefinitionNames);<span class="keyword">for</span> (String beanName : beanNames) &#123;<span class="comment">// 合并父 Bean 中的配置，注意 &lt;bean id=&quot;&quot; class=&quot;&quot; parent=&quot;&quot; /&gt; 中的 parent，用的不多吧。</span>RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);<span class="comment">// 如果是非抽象的，单例的，非延迟初始化的</span><span class="keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;<span class="comment">// 判断是否是FactoryBean，FactoryBean 是一个特殊的Bean，能创建Bean。</span><span class="keyword">if</span> (isFactoryBean(beanName)) &#123;<span class="comment">// 如果是，名字前加个 &amp;。</span>Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> FactoryBean) &#123;<span class="keyword">final</span> FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;<span class="keyword">boolean</span> isEagerInit;<span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span> &amp;&amp; factory <span class="keyword">instanceof</span> SmartFactoryBean) &#123;isEagerInit = AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;)((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit,getAccessControlContext());&#125;<span class="keyword">else</span> &#123;isEagerInit = (factory <span class="keyword">instanceof</span> SmartFactoryBean &amp;&amp;((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());&#125;<span class="keyword">if</span> (isEagerInit) &#123;getBean(beanName);&#125;&#125;&#125;<span class="keyword">else</span> &#123;<span class="comment">// 不是FactoryBean就是普通的呗，走这里。</span>getBean(beanName);&#125;&#125;&#125;<span class="comment">// 此时所有的bean已经全部初始化好了，触发所有适用bean的初始化后回调。</span><span class="keyword">for</span> (String beanName : beanNames) &#123;Object singletonInstance = getSingleton(beanName);<span class="keyword">if</span> (singletonInstance <span class="keyword">instanceof</span> SmartInitializingSingleton) &#123;<span class="keyword">final</span> SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;<span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;smartSingleton.afterSingletonsInstantiated();<span class="keyword">return</span> <span class="keyword">null</span>;&#125;, getAccessControlContext());&#125;<span class="keyword">else</span> &#123;smartSingleton.afterSingletonsInstantiated();&#125;&#125;&#125;&#125;</code></pre><p>重点就是getBean，走起！</p><h3 id="doGetBean"><a href="#doGetBean" class="headerlink" title="doGetBean"></a>doGetBean</h3><pre><code class="highlight java"><span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException </span>&#123;<span class="comment">// 就说干实事的还是doXxx。</span><span class="keyword">return</span> doGetBean(name, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">false</span>);&#125;<span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(<span class="keyword">final</span> String name, <span class="meta">@Nullable</span> <span class="keyword">final</span> Class&lt;T&gt; requiredType,</span></span><span class="function"><span class="params"><span class="meta">@Nullable</span> <span class="keyword">final</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span> <span class="keyword">throws</span> BeansException </span>&#123;<span class="comment">// 转换bean name, 因为可能是别名。以及可能是FactoryBean de BeanName, 由于是带 &amp; 的。</span><span class="keyword">final</span> String beanName = transformedBeanName(name);Object bean;<span class="comment">// 判断是否已经创建过了。</span>Object sharedInstance = getSingleton(beanName);<span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;<span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;logger.trace(<span class="string">&quot;Returning eagerly cached instance of singleton bean &#x27;&quot;</span> + beanName +<span class="string">&quot;&#x27; that is not fully initialized yet - a consequence of a circular reference&quot;</span>);&#125;<span class="keyword">else</span> &#123;logger.trace(<span class="string">&quot;Returning cached instance of singleton bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);&#125;&#125;<span class="comment">// 如果是普通的Bean则直接返回，如果是FactoryBean则返回其创建的Bean。</span>bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="keyword">null</span>);&#125;<span class="keyword">else</span> &#123;<span class="comment">// 如果该beanName是prototype 的Bean 正在创建，那么应该是循环依赖的原因。</span><span class="comment">// Spring无法处理prototype 的Bean的循环依赖的问题。</span><span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;<span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName);&#125;BeanFactory parentBeanFactory = getParentBeanFactory();<span class="comment">// 检查这个BeanDefination是否存在在父容器中。</span><span class="keyword">if</span> (parentBeanFactory != <span class="keyword">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;<span class="comment">// Not found -&gt; check parent.</span>String nameToLookup = originalBeanName(name);<span class="keyword">if</span> (parentBeanFactory <span class="keyword">instanceof</span> AbstractBeanFactory) &#123;<span class="keyword">return</span> ((AbstractBeanFactory) parentBeanFactory).doGetBean(nameToLookup, requiredType, args, typeCheckOnly);&#125;<span class="keyword">else</span> <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;<span class="comment">// Delegation to parent with explicit args.</span><span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);&#125;<span class="keyword">else</span> <span class="keyword">if</span> (requiredType != <span class="keyword">null</span>) &#123;<span class="comment">// No args -&gt; delegate to standard getBean method.</span><span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);&#125;<span class="keyword">else</span> &#123;<span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup);&#125;&#125;<span class="keyword">if</span> (!typeCheckOnly) &#123;markBeanAsCreated(beanName);&#125;<span class="keyword">try</span> &#123;<span class="comment">// 合并父 BeanDefinition 与子 BeanDefinition。</span><span class="keyword">final</span> RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);checkMergedBeanDefinition(mbd, beanName, args);<span class="comment">// 获取depends-on，看方法里知道，如果有依赖，那么先get 依赖的实例。</span>String[] dependsOn = mbd.getDependsOn();<span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) &#123;<span class="keyword">for</span> (String dep : dependsOn) &#123;<span class="keyword">if</span> (isDependent(beanName, dep)) &#123;<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,<span class="string">&quot;Circular depends-on relationship between &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; and &#x27;&quot;</span> + dep + <span class="string">&quot;&#x27;&quot;</span>);&#125;<span class="comment">// 注册依赖和要创建的bean的，</span>registerDependentBean(dep, beanName);<span class="keyword">try</span> &#123;<span class="comment">// 说明如果有依赖，先获取依赖的Bean实例。</span>getBean(dep);&#125;<span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,<span class="string">&quot;&#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; depends on missing bean &#x27;&quot;</span> + dep + <span class="string">&quot;&#x27;&quot;</span>, ex);&#125;&#125;&#125;<span class="comment">// 判断是否单例。</span><span class="keyword">if</span> (mbd.isSingleton()) &#123;sharedInstance = getSingleton(beanName, () -&gt; &#123;<span class="keyword">try</span> &#123;<span class="comment">// 创建bean。</span><span class="keyword">return</span> createBean(beanName, mbd, args);&#125;<span class="keyword">catch</span> (BeansException ex) &#123;destroySingleton(beanName);<span class="keyword">throw</span> ex;&#125;&#125;);<span class="comment">// 和上面一样的。</span>bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);&#125;<span class="comment">// 如果是 原型的。</span><span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;Object prototypeInstance = <span class="keyword">null</span>;<span class="keyword">try</span> &#123;beforePrototypeCreation(beanName);prototypeInstance = createBean(beanName, mbd, args);&#125;<span class="keyword">finally</span> &#123;afterPrototypeCreation(beanName);&#125;bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);&#125;<span class="comment">// 既不是单例又不是原型的。</span><span class="keyword">else</span> &#123;String scopeName = mbd.getScope();<span class="keyword">final</span> Scope scope = <span class="keyword">this</span>.scopes.get(scopeName);<span class="keyword">if</span> (scope == <span class="keyword">null</span>) &#123;<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;No Scope registered for scope name &#x27;&quot;</span> + scopeName + <span class="string">&quot;&#x27;&quot;</span>);&#125;<span class="keyword">try</span> &#123;Object scopedInstance = scope.get(beanName, () -&gt; &#123;beforePrototypeCreation(beanName);<span class="keyword">try</span> &#123;<span class="keyword">return</span> createBean(beanName, mbd, args);&#125;<span class="keyword">finally</span> &#123;afterPrototypeCreation(beanName);&#125;&#125;);bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);&#125;<span class="keyword">catch</span> (IllegalStateException ex) &#123;<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName,<span class="string">&quot;Scope &#x27;&quot;</span> + scopeName + <span class="string">&quot;&#x27; is not active for the current thread; consider &quot;</span> +<span class="string">&quot;defining a scoped proxy for this bean if you intend to refer to it from a singleton&quot;</span>,ex);&#125;&#125;&#125;<span class="keyword">catch</span> (BeansException ex) &#123;cleanupAfterBeanCreationFailure(beanName);<span class="keyword">throw</span> ex;&#125;&#125;<span class="comment">// 检查required类型是否与实际bean实例的类型匹配。</span><span class="keyword">if</span> (requiredType != <span class="keyword">null</span> &amp;&amp; !requiredType.isInstance(bean)) &#123;<span class="keyword">try</span> &#123;T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);<span class="keyword">if</span> (convertedBean == <span class="keyword">null</span>) &#123;<span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());&#125;<span class="keyword">return</span> convertedBean;&#125;<span class="keyword">catch</span> (TypeMismatchException ex) &#123;<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;logger.trace(<span class="string">&quot;Failed to convert bean &#x27;&quot;</span> + name + <span class="string">&quot;&#x27; to required type &#x27;&quot;</span> +ClassUtils.getQualifiedName(requiredType) + <span class="string">&quot;&#x27;&quot;</span>, ex);&#125;<span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());&#125;&#125;<span class="keyword">return</span> (T) bean;&#125;</code></pre><p>反正看了这么多，核心就是createBean。那么看看createBean：</p><h3 id="createBean"><a href="#createBean" class="headerlink" title="createBean"></a>createBean</h3><pre><code class="highlight java"><span class="function"><span class="keyword">protected</span> Object <span class="title">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span><span class="function"><span class="keyword">throws</span> BeanCreationException </span>&#123;<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;logger.trace(<span class="string">&quot;Creating instance of bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);&#125;RootBeanDefinition mbdToUse = mbd;<span class="comment">// 确保此时解析了bean类。</span>Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);<span class="keyword">if</span> (resolvedClass != <span class="keyword">null</span> &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != <span class="keyword">null</span>) &#123;mbdToUse = <span class="keyword">new</span> RootBeanDefinition(mbd);mbdToUse.setBeanClass(resolvedClass);&#125;<span class="comment">// 处理override method，即 lookup-method 和 replace-method。</span><span class="keyword">try</span> &#123;mbdToUse.prepareMethodOverrides();&#125;<span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(mbdToUse.getResourceDescription(),beanName, <span class="string">&quot;Validation of method overrides failed&quot;</span>, ex);&#125;<span class="keyword">try</span> &#123;<span class="comment">// 如果有BeanPostProcessors，那么返回代理而不是目标bean实例的。</span>Object bean = resolveBeforeInstantiation(beanName, mbdToUse);<span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;<span class="keyword">return</span> bean;&#125;&#125;<span class="keyword">catch</span> (Throwable ex) &#123;<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbdToUse.getResourceDescription(), beanName,<span class="string">&quot;BeanPostProcessor before instantiation of bean failed&quot;</span>, ex);&#125;<span class="keyword">try</span> &#123;<span class="comment">// 核心，核心！！doXxx！！</span>Object beanInstance = doCreateBean(beanName, mbdToUse, args);<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;logger.trace(<span class="string">&quot;Finished creating instance of bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);&#125;<span class="keyword">return</span> beanInstance;&#125;<span class="keyword">catch</span> (BeanCreationException | ImplicitlyAppearedSingletonException ex) &#123;<span class="keyword">throw</span> ex;&#125;<span class="keyword">catch</span> (Throwable ex) &#123;<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbdToUse.getResourceDescription(), beanName, <span class="string">&quot;Unexpected exception during bean creation&quot;</span>, ex);&#125;&#125;</code></pre><h3 id="doCreateBean"><a href="#doCreateBean" class="headerlink" title="doCreateBean"></a>doCreateBean</h3><pre><code class="highlight java"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> <span class="meta">@Nullable</span> Object[] args)</span></span><span class="function"><span class="keyword">throws</span> BeanCreationException </span>&#123;<span class="comment">// BeanWrapper 是一个接口，它实现类包裹 bean 实例。</span>BeanWrapper instanceWrapper = <span class="keyword">null</span>;<span class="comment">// 如果是单例。</span><span class="keyword">if</span> (mbd.isSingleton()) &#123;<span class="comment">// 看到这个变量的名字没，factoryBeanInstanceCache，说明是从factoryBean缓存中删除。</span>instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);&#125;<span class="comment">// 如果为空，说明上面没有factoryBean，说明不是。</span><span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;<span class="comment">// 在这create Bean。</span>instanceWrapper = createBeanInstance(beanName, mbd, args);&#125;<span class="comment">// 获取实例化好的bean，暂时没填充属性。</span><span class="keyword">final</span> Object bean = instanceWrapper.getWrappedInstance();<span class="comment">// 类型。</span>Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();<span class="keyword">if</span> (beanType != NullBean.class) &#123;mbd.resolvedTargetType = beanType;&#125;<span class="comment">// Allow post-processors to modify the merged bean definition.</span><span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;<span class="keyword">if</span> (!mbd.postProcessed) &#123;<span class="keyword">try</span> &#123;applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);&#125;<span class="keyword">catch</span> (Throwable ex) &#123;<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,<span class="string">&quot;Post-processing of merged bean definition failed&quot;</span>, ex);&#125;mbd.postProcessed = <span class="keyword">true</span>;&#125;&#125;<span class="comment">// 如果是单例的，允许循环依赖的，同时是否存于创建状态中。</span><span class="comment">// 看单词意思，早期单例曝光，这个变量用于解决循环依赖。</span><span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp;isSingletonCurrentlyInCreation(beanName));<span class="keyword">if</span> (earlySingletonExposure) &#123;<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;logger.trace(<span class="string">&quot;Eagerly caching bean &#x27;&quot;</span> + beanName +<span class="string">&quot;&#x27; to allow for resolving potential circular references&quot;</span>);&#125;addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));&#125;<span class="comment">// Initialize the bean instance.</span>Object exposedObject = bean;<span class="keyword">try</span> &#123;<span class="comment">// 在这，填充前面实例化好的bean的属性。</span>populateBean(beanName, mbd, instanceWrapper);         <span class="comment">// 处理 bean 初始化完成后的各种回调。</span>exposedObject = initializeBean(beanName, exposedObject, mbd);&#125;<span class="keyword">catch</span> (Throwable ex) &#123;<span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;<span class="keyword">throw</span> (BeanCreationException) ex;&#125;<span class="keyword">else</span> &#123;<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName, <span class="string">&quot;Initialization of bean failed&quot;</span>, ex);&#125;&#125;<span class="keyword">if</span> (earlySingletonExposure) &#123;Object earlySingletonReference = getSingleton(beanName, <span class="keyword">false</span>);<span class="keyword">if</span> (earlySingletonReference != <span class="keyword">null</span>) &#123;<span class="keyword">if</span> (exposedObject == bean) &#123;exposedObject = earlySingletonReference;&#125;<span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;String[] dependentBeans = getDependentBeans(beanName);Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(dependentBeans.length);<span class="keyword">for</span> (String dependentBean : dependentBeans) &#123;<span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;actualDependentBeans.add(dependentBean);&#125;&#125;<span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;<span class="comment">// 抛异常的，我给注释了。</span>&#125;&#125;&#125;&#125;<span class="comment">// Register bean as disposable.</span><span class="keyword">try</span> &#123;registerDisposableBeanIfNecessary(beanName, bean, mbd);&#125;<span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName, <span class="string">&quot;Invalid destruction signature&quot;</span>, ex);&#125;<span class="keyword">return</span> exposedObject;&#125;</code></pre><p>重点嘛，很明显，就是createBeanInstance：</p><h3 id="createBeanInstance"><a href="#createBeanInstance" class="headerlink" title="createBeanInstance"></a>createBeanInstance</h3><pre><code class="highlight java"><span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">createBeanInstance</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span> </span>&#123;<span class="comment">// 保证此时已经解决bean class。</span>Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);<span class="comment">// 判断访问权限，如果不行，抛异常。</span><span class="keyword">if</span> (beanClass != <span class="keyword">null</span> &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) &#123;<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,<span class="string">&quot;Bean class isn&#x27;t public, and non-public access not allowed: &quot;</span> + beanClass.getName());&#125;<span class="comment">// 返回用于创建bean实例的回调（如果有）。</span>Supplier&lt;?&gt; instanceSupplier = mbd.getInstanceSupplier();<span class="keyword">if</span> (instanceSupplier != <span class="keyword">null</span>) &#123;<span class="keyword">return</span> obtainFromSupplier(instanceSupplier, beanName);&#125;<span class="keyword">if</span> (mbd.getFactoryMethodName() != <span class="keyword">null</span>) &#123;<span class="comment">// 使用工厂方法实例化Bean。</span><span class="keyword">return</span> instantiateUsingFactoryMethod(beanName, mbd, args);&#125;<span class="comment">// 如果这个是创建过的bean，那么用一种快捷的方式，单例是不会重复创建的，所以一般是原型模式。</span><span class="keyword">boolean</span> resolved = <span class="keyword">false</span>;<span class="keyword">boolean</span> autowireNecessary = <span class="keyword">false</span>;<span class="keyword">if</span> (args == <span class="keyword">null</span>) &#123;<span class="keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;<span class="keyword">if</span> (mbd.resolvedConstructorOrFactoryMethod != <span class="keyword">null</span>) &#123;resolved = <span class="keyword">true</span>;autowireNecessary = mbd.constructorArgumentsResolved;&#125;&#125;&#125;<span class="keyword">if</span> (resolved) &#123;<span class="keyword">if</span> (autowireNecessary) &#123; <span class="comment">// 使用 构造方法自动注入 构造 bean 对象。 </span><span class="keyword">return</span> autowireConstructor(beanName, mbd, <span class="keyword">null</span>, <span class="keyword">null</span>);&#125;<span class="keyword">else</span> &#123;<span class="comment">// 使用 默认构造方法 构造 bean 对象</span><span class="keyword">return</span> instantiateBean(beanName, mbd);&#125;&#125;<span class="comment">// Candidate constructors for autowiring?</span>Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);<span class="keyword">if</span> (ctors != <span class="keyword">null</span> || mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR ||mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) &#123;<span class="keyword">return</span> autowireConstructor(beanName, mbd, ctors, args);&#125;<span class="comment">// Preferred constructors for default construction?</span>ctors = mbd.getPreferredConstructors();<span class="keyword">if</span> (ctors != <span class="keyword">null</span>) &#123;<span class="keyword">return</span> autowireConstructor(beanName, mbd, ctors, <span class="keyword">null</span>);&#125;<span class="comment">// No special handling: simply use no-arg constructor.</span><span class="keyword">return</span> instantiateBean(beanName, mbd);&#125;</code></pre><p>难的就不看了，看简单的默认构造方法创建的。instantiateBean走起！</p><h3 id="instantiateBean"><a href="#instantiateBean" class="headerlink" title="instantiateBean"></a>instantiateBean</h3><pre><code class="highlight java"><span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">instantiateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd)</span> </span>&#123;<span class="keyword">try</span> &#123;Object beanInstance;<span class="keyword">final</span> BeanFactory parent = <span class="keyword">this</span>;<span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;beanInstance = AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt;getInstantiationStrategy().instantiate(mbd, beanName, parent),getAccessControlContext());&#125;<span class="keyword">else</span> &#123;<span class="comment">// 调用实例化策略创建实例，默认情况下使用反射创建对象。</span>beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);&#125;BeanWrapper bw = <span class="keyword">new</span> BeanWrapperImpl(beanInstance);initBeanWrapper(bw);<span class="keyword">return</span> bw;&#125;<span class="keyword">catch</span> (Throwable ex) &#123;<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName, <span class="string">&quot;Instantiation of bean failed&quot;</span>, ex);&#125;&#125;<span class="function"><span class="keyword">public</span> Object <span class="title">instantiate</span><span class="params">(RootBeanDefinition bd, <span class="meta">@Nullable</span> String beanName, BeanFactory owner)</span> </span>&#123;<span class="comment">// 如果没有override method就用反射，如果有，就用CGLIB。</span><span class="comment">// override method前面说了，是lookup-method 和 replaced-method </span><span class="keyword">if</span> (!bd.hasMethodOverrides()) &#123;Constructor&lt;?&gt; constructorToUse;<span class="keyword">synchronized</span> (bd.constructorArgumentLock) &#123;constructorToUse = (Constructor&lt;?&gt;) bd.resolvedConstructorOrFactoryMethod;<span class="keyword">if</span> (constructorToUse == <span class="keyword">null</span>) &#123;<span class="keyword">final</span> Class&lt;?&gt; clazz = bd.getBeanClass();<span class="keyword">if</span> (clazz.isInterface()) &#123;<span class="keyword">throw</span> <span class="keyword">new</span> BeanInstantiationException(clazz, <span class="string">&quot;Specified class is an interface&quot;</span>);&#125;<span class="keyword">try</span> &#123;<span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;constructorToUse = AccessController.doPrivileged((PrivilegedExceptionAction&lt;Constructor&lt;?&gt;&gt;) clazz::getDeclaredConstructor);&#125;<span class="keyword">else</span> &#123;constructorToUse = clazz.getDeclaredConstructor();&#125;bd.resolvedConstructorOrFactoryMethod = constructorToUse;&#125;<span class="keyword">catch</span> (Throwable ex) &#123;<span class="keyword">throw</span> <span class="keyword">new</span> BeanInstantiationException(clazz, <span class="string">&quot;No default constructor found&quot;</span>, ex);&#125;&#125;&#125;<span class="comment">// 使用无参构造方法创建。</span><span class="keyword">return</span> BeanUtils.instantiateClass(constructorToUse);&#125;<span class="keyword">else</span> &#123;<span class="comment">// 使用CGLIB 创建。</span><span class="keyword">return</span> instantiateWithMethodInjection(bd, beanName, owner);&#125;&#125;</code></pre><p>至此，Bean实例化总算完成了！！还有属性怎么填充的我就不说了，因为也写了这么多，其实实例化的Bean的我写的还是没那么详细的，有些我想留着下一篇写Spring如何解决循环依赖的时候再仔细写一下！</p><p>总结啥的也不说了，反正都在文章里了。</p><p><strong>最后，谢谢观看。本人才疏学浅，如有错误之处，欢迎指正，共同进步。</strong></p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> Spring源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java线程池源码分析</title>
      <link href="2019/07/01/java-xian-cheng-chi-yuan-ma-fen-xi/"/>
      <url>2019/07/01/java-xian-cheng-chi-yuan-ma-fen-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>我这里先告知一些应该知道的基本概念：</p><ol><li>我们向线程池提交的都是一个个任务，这些任务都是实现了Runnable 接口的，Runnable的run方法是没有返回值的。<strong>而线程池是可以获取线程执行的结果的，返回的是Future</strong>。因此，线程池其实是对提交的任务进行了包装了的，线程池将Runnable包装成Callable（<strong>Callable和Runnable的区别在于Callable是有返回值的</strong>），再将Callable包装成FutureTask，而FutureTask继承自 Future，Future可以用来表示一个任务的生命周期。</li><li>线程池还使用了阻塞队列（在下面的源码分析中叫<strong>工作队列</strong>）来进行任务的排队，队列一般分为有界队列，无界队列，和同步移交（Synchronous Handoff）。使用的比较多的是ArrayBlockingQueue 和 LinkedBlockingQueue，这里提一句同步移交，一般对于非常大或者无界的线程池，可以通过SychronousQueue来避免任务排队，直接将任务从生产者移交给工作者线程，它不算是真正的队列，只是一种移交机制而已，因此，如果线程池中没有线程接收任务，且当前线程大小大于最大大小的时候，就会执行饱和策略。（关于同步移交的可能有点模糊，但是看完之后相信你就能理解的）</li></ol><h2 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h2><p>在看具体的源码之前，照例来看看它继承关系：</p><p><img src="https://img-blog.csdnimg.cn/20190628113003188.png" alt="ThreadPoolExecutor "></p><p>一般来说，这个线程池的基石是Executor接口，这个模式基于生产者-消费者模式不过由于它只有一个方法 execute(Runnable runnable)，因此实际上常用的是ExecutorService ，它也是一个接口，但是在Executor的基础上增加了许多方法。</p><h3 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a>ExecutorService</h3><p>ExecutorService 的生命周期有三个状态： 运行、关闭和终止。</p><p>下面看看ExecutorService下常用的方法：</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecutorService</span> <span class="keyword">extends</span> <span class="title">Executor</span> </span>&#123;<span class="comment">// 平缓的关闭，不再接受新任务，同时等待已经提交给队列的任务完成。</span>    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;    <span class="comment">// 比较粗暴的关闭，会取消所有在运行的任务，那么肯定连队列中的任务也不会再执行。</span>    <span class="function">List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span></span>;    <span class="comment">// 是否关闭。</span>    <span class="function"><span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span></span>;    <span class="comment">// 是否终止。需要注意的是，必须先调用shutdown()和shutdownNow()才会返回true，否则是不会返回true的。</span>    <span class="function"><span class="keyword">boolean</span> <span class="title">isTerminated</span><span class="params">()</span></span>;    <span class="comment">// 提交Callable的任务。</span>    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;    <span class="comment">// 提交Runnable的任务，result是做完返回值的。</span>    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;    <span class="comment">// 提交Runnable任务。</span>    Future&lt;?&gt; submit(Runnable task);&#125;</code></pre><h3 id="AbstractExecutorService"><a href="#AbstractExecutorService" class="headerlink" title="AbstractExecutorService"></a>AbstractExecutorService</h3><p>下面再来看看AbstractExecutorService，这里也是只讲一下重要的方法：</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractExecutorService</span> <span class="keyword">implements</span> <span class="title">ExecutorService</span> </span>&#123;<span class="comment">// 点进new FutureTask 会看见是先是包装成Callable再赋值给其中的callable变量。</span>    <span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Runnable runnable, T value)</span> </span>&#123;        <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(runnable, value);    &#125;    <span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Callable&lt;T&gt; callable)</span> </span>&#123;        <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(callable);    &#125;        <span class="comment">// 将Runnable 包装成RunnableFuture（最开始的基本概念已经说了）。</span><span class="comment">// 再调用上面的newTaskFor方法。</span><span class="comment">// 下面的大都类似，就不说了。</span>    <span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;        <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();        RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="keyword">null</span>);        execute(ftask);        <span class="keyword">return</span> ftask;    &#125;    <span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span> </span>&#123;        <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();        RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);        execute(ftask);        <span class="keyword">return</span> ftask;    &#125;    <span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123;        <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();        RunnableFuture&lt;T&gt; ftask = newTaskFor(task);        execute(ftask);        <span class="keyword">return</span> ftask;    &#125;&#125;</code></pre><h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><p>下面就是重点对象 ThreadPoolExecutor 类了，它继承自AbstractExecutorService，AbstractExecutorService继承自ExecutorService 。</p><h3 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h3><p>在看源码之前，先了解线程池的几个状态：</p><ul><li>  RUNNING:   接受新任务以及处理等待队列中的任务。</li><li>  SHUTDOWN:  不接受新任务，但是能处理等待队列中的任务。</li><li>  STOP:   不接受新任务，也不处理等待队列中的任务，还要中断执行任务的线程。   </li><li>  TIDYING:  所有的任务已经终止了，workerCount（正在工作的线程数） 为0，这个状态就会过渡为TIDYING，将会运行 terminated()这个钩子方法。</li><li>  TERMINATED: terminated() 运行完。</li></ul><p>在ThreadPoolExectuor</p><pre><code class="highlight java"><span class="comment">// COUNT_BITS 为29，为什么是29，因为int总共有32位，线程池用前面3位表示线程池状态，后面29存放线程数</span>   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;   <span class="comment">// 000 1...，五亿多。</span>   <span class="comment">// 表示的是线程池能创建的最大线程数，一般也不会达到这个数量级。</span>   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;   <span class="comment">// 线程池的各个状态码 后面29位都是0的</span>   <span class="comment">// 111 0...</span>   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;   <span class="comment">// 000 0...</span>   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;   <span class="comment">// 001 0...</span>   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;   <span class="comment">// 010 0...</span>   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;   <span class="comment">// 011 0...</span>   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</code></pre><p>从上面可以看见，**==这里注意一下，RUNNING是负数，SHUTDOWN是0，其它的都是大于0的。==**</p><p>然后获取线程池当前的状态和线程数是这样的：</p><pre><code class="highlight java"><span class="comment">// 将整数 c 的低 29 位修改为 0，就得到了线程池的状态</span><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;<span class="comment">// 将整数 c 的高 3 为修改为 0，就得到了线程池中的线程数</span><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</code></pre><p>状态之间的转变如下：</p><ul><li>RUNNING -&gt; SHUTDOWN：调用shutdown()方法，也可能隐含在finalize()中。</li><li>(RUNNING or SHUTDOWN) -&gt; STOP：调用shutdownNow()方法。从这里也可以看出这也是上面ExecutorService讲shutdownNow()和shutdown()区别。</li><li>SHUTDOWN -&gt; TIDYING：当队列和线程池是空的时候。</li><li>STOP -&gt; TIDYING：当线程池空的时候。</li><li>TIDYING -&gt; TERMINATED：当terminated()这个钩子方法执行完成。</li></ul><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p><strong><em>看完了上面的线程池状态讲解，下面正式来读源码，相信看到这里的你已经算是比较有耐心的了。</em></strong></p><p>这次不从变量和构造方法来讲解，而是从常见的新建一个线程池入手。首先，很多人会用Executors这个工具类来创建线程池，一般是这样的：</p><pre><code class="highlight java">Executors.newSingleThreadExecutor();Executors.newFixedThreadPool();</code></pre><p>当然还有其他的类型，就不列出来了。当我们点进去看的时候，就会出现下面的：</p><pre><code class="highlight java"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,                                      <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());    &#125;<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;<span class="comment">// 这个被FinalizableDelegatedExecutorService再次封装，是不允许修改里面的参数的意思。</span>        <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService            (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,                                    <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));    &#125;</code></pre><p>这两个都指向了ThreadPoolExecutor的构造方法。</p><pre><code class="highlight java"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span><span class="function"><span class="params">                              TimeUnit unit,</span></span><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span><span class="function"><span class="params">                              ThreadFactory threadFactory)</span> </span>&#123;        <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,             threadFactory, defaultHandler);&#125;<span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span><span class="function"><span class="params">                              TimeUnit unit,</span></span><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span><span class="function"><span class="params">                              ThreadFactory threadFactory,</span></span><span class="function"><span class="params">                              RejectedExecutionHandler handler)</span> </span>&#123;        <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||            maximumPoolSize &lt;= <span class="number">0</span> ||            maximumPoolSize &lt; corePoolSize ||            keepAliveTime &lt; <span class="number">0</span>)            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();        <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();        <span class="keyword">this</span>.acc = System.getSecurityManager() == <span class="keyword">null</span> ?                <span class="keyword">null</span> :                AccessController.getContext();        <span class="keyword">this</span>.corePoolSize = corePoolSize;        <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;        <span class="keyword">this</span>.workQueue = workQueue;        <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);        <span class="keyword">this</span>.threadFactory = threadFactory;        <span class="keyword">this</span>.handler = handler;    &#125;</code></pre><p>上面的这些参数基本上就是线程池的核心变量了，下面讲一下这些变量。</p><table><thead><tr><th>变量</th><th>作用</th></tr></thead><tbody><tr><td>corePoolSize</td><td>核心线程数，一直存活在线程池中，除非allowCoreThreadTimeOut为true，否则即使它们是空闲的， 也不回收。</td></tr><tr><td>maximumPoolSize</td><td>最大线程数，线程池运行的最大的线程数。与上面CAPACITY是有区别的。</td></tr><tr><td>keepAliveTime</td><td>存活时间，当线程池中的线程数大于核心线程数，且超过这个时间了还没任务做，那么该线程将会被终止。</td></tr><tr><td>unit</td><td>存活时间的单位</td></tr><tr><td>workQueue</td><td>工作队列，在前面基本概念中提了。</td></tr><tr><td>threadFactory</td><td>线程工厂，顾名思义，就是生产线程的。一般建议用一个带名字的。</td></tr><tr><td>handler</td><td>饱和策略，一般当线程池中线程数量达到最大线程数，且工作队列也满了的时候，会执行饱和策略。</td></tr></tbody></table><h4 id="execute方法"><a href="#execute方法" class="headerlink" title="execute方法"></a>execute方法</h4><p>下面看看最核心的execute方法了：</p><pre><code class="highlight java"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;<span class="comment">// 如果提交的任务为null，抛出空指针异常。</span>        <span class="keyword">if</span> (command == <span class="keyword">null</span>)            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();        <span class="comment">// 这个就是上面说的结合 线程池状态和线程数的 整数</span>        <span class="keyword">int</span> c = ctl.get();        <span class="comment">// 获得线程池中的线程数，如果小于核心线程大小。</span>        <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;        <span class="comment">// 下面会有详细解释，这里大概解释一下。</span>        <span class="comment">// 线程池新建一个线程，并将任务提交给这个线程，并成功启动，就会返回true。</span>        <span class="comment">// 为false就表示不允许提交任务。</span>        <span class="comment">// 如果第二个参数的作用表示界限，为true表示以核心线程数为界限，false则是以最大线程数为界限。</span>            <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))                <span class="keyword">return</span>;            c = ctl.get();        &#125;        <span class="comment">// 到这里说明当前线程大小大于核心线程数，或者提交任务失败。</span><span class="comment">// 如果线程池状态是RUNNING，并且向工作队列添加任务成功。</span>        <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;            <span class="keyword">int</span> recheck = ctl.get();            <span class="comment">// 再次检查线程池状态，如果不是RUNNING了，那么执行拒绝策略。</span>            <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))                reject(command);            <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>) <span class="comment">// 如果还是RUNNING，且线程池中没线程。</span>                addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);        &#125;        <span class="comment">// 如果不是RUNNING状态，或者工作队列满了，就执行这一步。</span>        <span class="comment">// 使用maximumPoolSize为界限再试一次addWorker方法，如果还是失败，那么执行饱和策略</span>        <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))            reject(command);    &#125;</code></pre><p>可能乍一看上去有点绕，梳理一下：</p><ol><li>我们通过execute提交任务，<strong>如果当前线程池中的线程数小于核心线程数</strong>，那么以<strong>核心线程数为界</strong>新建线程来处理这个任务，成功就没什么可说的了，失败就表示可能出现了点变化。</li><li>如果不小于核心线程数，或者上一步失败了。那么如果线程池状态还是运行的，将任务放到工作队列中去，如果放进去之后发现线程池状态改变了，那么将刚放进去的任务移出，然后执行饱和策略。如果线程池状态没改变，且当前工作线程数为0，那么新建线程。</li><li>如果线程池状态不是运行状态或者工作队列满了，那么再以<strong>最大线程数为界</strong>新建线程来处理这个任务，成功就没什么可说的了，失败就执行饱和策略。</li></ol><h4 id="addWorker方法"><a href="#addWorker方法" class="headerlink" title="addWorker方法"></a>addWorker方法</h4><p>现在看下addWorker(Runnable firstTask, boolean core)方法是如何新建线程的：</p><pre><code class="highlight java"><span class="comment">// firstTask表示的是任务，core为true绑定的是核心线程大小，为false绑定的是最大线程大小。</span><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;<span class="comment">// 这是一个跳出符，类似goto，不知道的可以谷歌一下。</span>       retry:       <span class="keyword">for</span> (;;) &#123;           <span class="keyword">int</span> c = ctl.get();           <span class="comment">// 获得线程池的状态。</span>           <span class="keyword">int</span> rs = runStateOf(c);<span class="comment">// 这个if的逻辑可能有点难理解，但是仔细想想也还好，满足下面的条件之一就行。</span><span class="comment">// 1.线程池的状态大于SHUTDOWN（最开始的时候也说了，RUNNING状态是负数的）。</span><span class="comment">// 2.如果线程池状态为SHUTDOWN，提交的任务不为null。</span><span class="comment">// 3.如果线程池状态为SHUTDOWN，提交的任务为null，工作队列为空。</span><span class="comment">// 这里简单的分析下上面的情况：</span><span class="comment">// 1.线程池状态大于0，那肯定不是RUNNING和SHUTDOWN状态了吗，return false完全没毛病。</span><span class="comment">// 这里重复一下，SHUTDOWN状态不接受新任务，但是会处理工作队列中的任务。</span><span class="comment">// 2.SHUTDOWN状态时，任务不为null，肯定是要return false的。</span><span class="comment">// 3.任务为null，工作队列也是空的，肯定是返回false的。</span><span class="comment">// 引申一下，如果状态为SHUTDOWN，工作队列不为null还是会新建线程的，原因看SHUTDOWN的意义。</span>           <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;               ! (rs == SHUTDOWN &amp;&amp;                  firstTask == <span class="keyword">null</span> &amp;&amp;                  ! workQueue.isEmpty()))               <span class="keyword">return</span> <span class="keyword">false</span>;           <span class="comment">// 到这里说明上面的if判断为false，也就是没有满足上面的条件。</span>           <span class="keyword">for</span> (;;) &#123;           <span class="comment">// 获得当前的线程池中的线程数。</span>               <span class="keyword">int</span> wc = workerCountOf(c);               <span class="comment">// 如果当前线程数大于CAPACITY</span>               <span class="comment">// 或者core为true时大于核心大小，为false时大于最大大小，返回false。</span>               <span class="keyword">if</span> (wc &gt;= CAPACITY ||                   wc &gt;= (core ? corePoolSize : maximumPoolSize))                   <span class="keyword">return</span> <span class="keyword">false</span>;               <span class="comment">// 将那个整数值加一！说白了就是线程数+1，这里使用的是cas，成功就跳出循环，失败就走下面。</span>               <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))                   <span class="keyword">break</span> retry;               <span class="comment">// 再次获得这个整数。</span>               c = ctl.get();               <span class="comment">// 如果和最开始的运行状态不一致，那么再从for来一遍。</span>               <span class="keyword">if</span> (runStateOf(c) != rs)                   <span class="keyword">continue</span> retry;           &#125;       &#125;       <span class="comment">// 都到这里了说明一个return都没发生，跳出了for循环，那个整数+1成功了。</span>              <span class="comment">// 线程是否开始工作</span>       <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;       <span class="comment">// 是否有将work添加到workers 中。</span>       <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;       Worker w = <span class="keyword">null</span>;       <span class="keyword">try</span> &#123;       <span class="comment">// 线程池新建一个线程，包装成Worker类。</span>           w = <span class="keyword">new</span> Worker(firstTask);           <span class="keyword">final</span> Thread t = w.thread;           <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;           <span class="comment">// 这是线程池的全局锁。</span>               <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;               <span class="comment">// 锁住这个线程池。</span>               mainLock.lock();               <span class="keyword">try</span> &#123;                                      <span class="keyword">int</span> rs = runStateOf(ctl.get());                   <span class="comment">// 状态为RUNNING或者为SHUTDOWN时，不接受新的任务，处理工作队列，这个上面说过。</span>                   <span class="keyword">if</span> (rs &lt; SHUTDOWN ||                       (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;                       <span class="comment">// 检查这个新建线程是不是已经启动了，启动了抛异常。</span>                       <span class="keyword">if</span> (t.isAlive())                            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();                       <span class="comment">// 将新建的work添加到workers中，是一个HashSet。</span>                       workers.add(w);                       <span class="comment">// largestPoolSize记录线程池中有过线程数的最大值。</span>                       <span class="keyword">int</span> s = workers.size();                       <span class="keyword">if</span> (s &gt; largestPoolSize)                           largestPoolSize = s;                         workerAdded = <span class="keyword">true</span>;                   &#125;               &#125; <span class="keyword">finally</span> &#123;                   mainLock.unlock();               &#125;               <span class="comment">// 如果已经将worker添加到了workers中，启动这个worker。</span>               <span class="keyword">if</span> (workerAdded) &#123;                   t.start();                   workerStarted = <span class="keyword">true</span>;               &#125;           &#125;       &#125; <span class="keyword">finally</span> &#123;       <span class="comment">// 如果线程没启动，那么做一些回退动作。</span>       <span class="comment">// 将worker从workers去掉，将之前+1的线程数减掉，试着将状态调到TERMINATED。</span>           <span class="keyword">if</span> (! workerStarted)               addWorkerFailed(w);       &#125;       <span class="comment">// 返回线程是否启动成功。</span>       <span class="keyword">return</span> workerStarted;   &#125;</code></pre><p>这个方法看上去也有点绕，但是只要记住其作用<strong>核心是新建线程</strong>就行了。</p><h4 id="Worker类"><a href="#Worker类" class="headerlink" title="Worker类"></a>Worker类</h4><p>这里看下Worker类（只列出变量、构造方法和run方法）：</p><pre><code class="highlight java"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span></span><span class="class">      <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span><span class="class">      <span class="keyword">implements</span> <span class="title">Runnable</span></span><span class="class">  </span>&#123;      <span class="keyword">final</span> Thread thread;            <span class="comment">// 如果新建线程的时候同时指定了任务，那么新建的线程第一个执行这个任务（所以叫firstTask）</span>      <span class="comment">// 当然这个任务也可以为null。</span>      Runnable firstTask;            <span class="comment">// 存放这个线程完成的任务数量，使用了volatile修饰。</span>      <span class="keyword">volatile</span> <span class="keyword">long</span> completedTasks;      <span class="comment">// 传入任务，</span>      Worker(Runnable firstTask) &#123;          setState(-<span class="number">1</span>);           <span class="keyword">this</span>.firstTask = firstTask;          <span class="comment">// 使用线程工厂来创建一个线程。</span>          <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);      &#125;      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;          runWorker(<span class="keyword">this</span>);      &#125;        &#125;</code></pre><p>从Worker源码可以看出，这个类继承自AQS（可以说是无处不在的AQS，并发的基石）。其实从这里可以知道，线程池中的线程都包装成了Worker（译作工人）。话说Doug Lea大神的形容真传神，<strong>处理任务（Runnable）的是工人（Worker）。</strong>，上面那个addWorker，译作添加工人也完全形象。</p><h4 id="runWorker-方法"><a href="#runWorker-方法" class="headerlink" title="runWorker 方法"></a>runWorker 方法</h4><p>我们知道，在addWorker方法中将新建线程启动会调用Worker中的run()方法， 它再调用runWorker(this)，那么看一下这个runWorker方法：</p><pre><code class="highlight java"><span class="comment">// 不断的从队列中获取任务并执行，同时解决一些问题。</span><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;       Thread wt = Thread.currentThread();       <span class="comment">// 新建线程传递的那个任务，也可以为null。</span>       Runnable task = w.firstTask;       w.firstTask = <span class="keyword">null</span>;       w.unlock(); <span class="comment">// allow interrupts</span>       <span class="comment">// 标识符。</span>       <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;       <span class="keyword">try</span> &#123;       <span class="comment">// 一直调用getTask获取任务去执行。</span>           <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;               w.lock();               <span class="comment">// 如果线程池状态是STOP或以上（就是状态值大于STOP的），确保这个线程执行中断。</span>               <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||                    (Thread.interrupted() &amp;&amp;                     runStateAtLeast(ctl.get(), STOP))) &amp;&amp;                   !wt.isInterrupted())                   wt.interrupt();               <span class="keyword">try</span> &#123;               <span class="comment">// 在运行任务前先执行，留给需要的子类进行。</span>                   beforeExecute(wt, task);                   Throwable thrown = <span class="keyword">null</span>;                   <span class="keyword">try</span> &#123;                       task.run();                   &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;                       thrown = x; <span class="keyword">throw</span> x;                   &#125; <span class="keyword">catch</span> (Error x) &#123;                       thrown = x; <span class="keyword">throw</span> x;                   &#125; <span class="keyword">catch</span> (Throwable x) &#123;                   <span class="comment">// 除了运行时异常的异常不让抛，弄成error抛出去。</span>                       thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);                   &#125; <span class="keyword">finally</span> &#123;                   <span class="comment">// 同beforeExecute作用类似，在运行任务结束后执行。</span>                       afterExecute(task, thrown);                   &#125;               &#125; <span class="keyword">finally</span> &#123;                   task = <span class="keyword">null</span>;                   <span class="comment">// 该线程完成的任务数++。</span>                   w.completedTasks++;                   w.unlock();               &#125;           &#125;           <span class="comment">// 到这里说明完整的执行了一个任务，没有抛出异常。</span>           completedAbruptly = <span class="keyword">false</span>;       &#125; <span class="keyword">finally</span> &#123;       <span class="comment">// 到这里了说明getTask()拿不到任务了或者任务执行的过程中发生异常。</span>       <span class="comment">// 如果是拿不到任务了，getTask()自会将workCount - 1 的</span>       <span class="comment">// 如果是抛异常，那么执行这个方法将workCount - 1</span>           processWorkerExit(w, completedAbruptly);       &#125;   &#125;</code></pre><p>这个方法很好理解，不解释。</p><h4 id="getTask-方法"><a href="#getTask-方法" class="headerlink" title="getTask 方法"></a>getTask 方法</h4><p>下面看看getTask()：</p><pre><code class="highlight java"><span class="comment">// 阻塞直到获取到任务然后返回。</span><span class="comment">// 也会返回null，返回null的情况为以下几种：</span><span class="comment">// 1.已经有大于maximumPoolSize的线程数了</span><span class="comment">// 2.线程池的状态为STOP，或者为SHUTDOWN，且工作队列为空。</span><span class="comment">// 3.线程等待keepAliveTime 时间了，线程要回收了，</span><span class="comment">//      但是如果目前线程数小于corePoolSize则不会，除非allowCoreThreadTimeOut设为true。</span><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;<span class="comment">// 表超时。</span>       <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span>       <span class="keyword">for</span> (;;) &#123;           <span class="keyword">int</span> c = ctl.get();           <span class="keyword">int</span> rs = runStateOf(c);           <span class="comment">// 这里可以分为两种情况。</span>           <span class="comment">// 1. 状态大于等于STOP。</span>           <span class="comment">// 2. 状态为SHUTDOWN，且工作队列为空。 </span>           <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;           <span class="comment">// 通过cas将工作线程数-1.</span>               decrementWorkerCount();               <span class="keyword">return</span> <span class="keyword">null</span>;           &#125;           <span class="keyword">int</span> wc = workerCountOf(c);           <span class="comment">// 如果allowCoreThreadTimeOut 为true（前面说过，允许回收核心线程数内的线程）</span>           <span class="comment">// 或者工作线程数大于核心线程数，那么就会超时关闭了。</span>           <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;                      <span class="comment">// 意图是让工作线程数-1，if只要满足下面条件之一。</span>           <span class="comment">// 1. 工作线程大于最大线程数。</span>           <span class="comment">// 2. timed &amp;&amp; timedOut为true，且 工作线程数大于1或者工作队列为空。</span>           <span class="comment">// 讲解一下条件2。</span>           <span class="comment">// timed为false时，意味着当前工作线程数小于核心线程数，不管timedOut超时标志是不是true，if都为false。</span>           <span class="comment">// 假设timed为true，且timedOut超时标志为true，只要工作线程大于1或者工作队列为空了（回收最后一个线程）</span>           <span class="comment">// 核心只要记住一句话。</span>           <span class="comment">// 如果allowCoreThreadTimeOut为true，回收所有空闲超时线程，否则，回收大于核心线程数的空闲超时线程。</span>           <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))               &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;               <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))                   <span class="keyword">return</span> <span class="keyword">null</span>;               <span class="keyword">continue</span>;           &#125;           <span class="comment">// 到这里就是 工作线程数小于等于maximumPoolSize 且 没有超时</span>           <span class="keyword">try</span> &#123;           <span class="comment">// workQueue 中获取任务</span>               Runnable r = timed ?                   workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :                   workQueue.take();               <span class="keyword">if</span> (r != <span class="keyword">null</span>)                   <span class="keyword">return</span> r;               timedOut = <span class="keyword">true</span>;           &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;           <span class="comment">// 如果捕获到中断异常，那么重头再来一次。</span>               timedOut = <span class="keyword">false</span>;           &#125;       &#125;   &#125;</code></pre><p>看到这里基本上差不多了。</p><h4 id="饱和策略"><a href="#饱和策略" class="headerlink" title="饱和策略"></a>饱和策略</h4><p>最后讲一下execute(Runnable command) 方法中可能会执行的reject(command);也就是饱和策略了，这里就不讲具体源码了，带着讲一下：</p><blockquote><p>ThreadPoolExecutor 中有四个已经写好了的饱和策略，一般就用这四个。</p><ol><li>AbortPolicy（中止策略）：会抛出未检查的RejectedExecutionException 异常，调用者可以捕获这个异常，然后根据需求编写处理代码。<strong>它也是默认的饱和策略。</strong></li><li>DiscardPolicy （抛弃策略）：直接抛弃该任务，不做任何处理的。</li><li>DiscardOldestPolicy （抛弃最旧策略）：如果线程池状态不为SHUTDOWN，将会抛弃下一个将被执行的任务，然后再把这个任务提交了。（这个操作有点骚气）</li><li>CallerRunsPolicy （调用者运行策略）：是一种调节机制，既不会抛弃任务，也不抛出异常， 而是将任务回退给调用者，如，主线程中调用execute方法，如果执行饱和策略后，将该任务的运行提交给主线程去执行，使得一定时间内，主线程无法提交任务。</li></ol></blockquote><h3 id="Executors下四种线程池"><a href="#Executors下四种线程池" class="headerlink" title="Executors下四种线程池"></a>Executors下四种线程池</h3><p>先看一下newFixedThreadPool，它的作用是创建出固定大小的线程池，因此可以看到它核心线程数和最大线程数是一样的，keepAliveTime 为0，因为最大线程数和核心线程数大小一样，所有这个没必要设置，使用LinkedBlockingQueue有界队列作为工作队列。</p><p>这样就可以分析一下，首先在线程池中线程数没有达到nThreads之前，一直是新建线程，达到了就将任务放置在LinkedBlockingQueue队列中，该队列满了就执行饱和策略。如果有线程发生了未预期的异常结束了，那么将补充一个线程。</p><pre><code class="highlight java"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads, ThreadFactory threadFactory)</span> </span>&#123;        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,                                      <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),                                      threadFactory);    &#125;</code></pre><p>newSingleThreadExecutor，它创建只有一个线程的线程池，除了将newFixedThreadPool中的nThreads改为1，其他都一样。<br>它主要是确保依照任务在队列中的顺序串行执行。</p><pre><code class="highlight java"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;        <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService            (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,                                    <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));    &#125;</code></pre><p>newCachedThreadPool，将创建一个可缓存的线程池，如果当前规模超过了处理需求时，将回收空闲的线程，需求增加时，则添加新线程，没有规模限制（其实还是有的，Integer.MAX_VALUE，不过肯定不会创建这么多线程）。它的工作队列设为SynchronousQueue，其作用在基本概念那里就已经说了。</p><pre><code class="highlight java"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,                                      <span class="number">60L</span>, TimeUnit.SECONDS,                                      <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());    &#125;</code></pre><p>newScheduledThreadPool，创建一个固定长度的线程池，而且以延迟或定时的方式来执行任务。这个由于没怎么接触过，所以就不多说了。</p><pre><code class="highlight java"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;        <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);    &#125;</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>哇，经过冗长冗长的一段，终于到了总结这里。我并没有将全部的方法贴过来，毕竟贴完我感觉就要gg了，只是贴了核心部分，但是这也够喝一壶了。其实，并没有什么好总结的……毕竟要说的都在代码里，感情深，一口闷！但还是略微的总结一下吧。</p><ul><li><strong>什么时候新建线程</strong>，首先，1. 如果线程池中工作线程数小于corePoolSize，那么提交任务时创建一个线程。2. 如果已经达到了corePoolSize数，那么将任务放置在workQueue中，<strong>这个时候是不会创建任务的</strong>。3.当队列满的时候，再提交任务，且工作线程数不大于maximumPoolSize，就会创建线程。</li><li><strong>什么时候回收线程</strong>，一句话，如果allowCoreThreadTimeOut为true，那么回收所有空闲超时线程，否则，回收大于corePoolSize的空闲超时线程。</li><li><strong>什么还是执行饱和策略</strong>，1. 当队列满了，且工作线程数已经大于等于maximumPoolSize了（此时肯定是大于等于corePoolSize的），那么执行饱和策略。2.工作线程数已经达到了 corePoolSize，任务放到workQueue中去，但有个线程已经将线程池关闭，且关闭线程池时没有将这个任务移出，那么执行饱和策略。有关这一块可以在execute()方法中看见。</li></ul><p> <strong>最后，谢谢观看。本人才疏学浅，如有错误之处，欢迎指正，共同进步。</strong></p>]]></content>
      
      
      <categories>
          
          <category> Java并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap源码分析（基于1.8版本）</title>
      <link href="2019/06/11/hashmap-yuan-ma-fen-xi-ji-yu-1.8-ban-ben/"/>
      <url>2019/06/11/hashmap-yuan-ma-fen-xi-ji-yu-1.8-ban-ben/</url>
      
        <content type="html"><![CDATA[<p>鉴于我本地安装的版本是1.8的，因此，分析1.8版本的是HashMap。最后会分析1.7和1.8的有什么区别。</p><p>首先，HashMap使用链地址法来解决hash冲突的问题，HashMap1.8使用的是数组+链表/红黑树。</p><p><strong>注：虽然是源码解析，但是并不是所有的源码都会涉及到，只涉及到经常使用的那些。</strong></p><p>来看看一些一些常量和变量，以及构造方法和hash方法。</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;    <span class="comment">// 默认的初始化容量，即默认的数组大小，为16.该值必须是2的次方。</span>    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span>    <span class="comment">// 最大的容量，为2的30次方。</span>    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;    <span class="comment">// 默认的负载因子。</span>    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;    <span class="comment">// 树形化的临界值。</span>    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;    <span class="comment">// 树形转回链表的临界值。</span>    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;    <span class="comment">// 如果没达到这个容量，会先扩容，而不是树形化。这样避免调整大小和树形化冲突。</span>    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;        <span class="comment">/**</span><span class="comment">    *   变量</span><span class="comment">   **/</span>    <span class="comment">// HashMap的数组定义</span>    <span class="keyword">transient</span> Node&lt;K,V&gt;[] table;        <span class="comment">// 做遍历时使用。</span>    <span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;    <span class="comment">// HashMap大小。</span>    <span class="keyword">transient</span> <span class="keyword">int</span> size;    <span class="comment">// HashMap结构改变的次数。</span>    <span class="keyword">transient</span> <span class="keyword">int</span> modCount;        <span class="comment">// 表示size大于它的时候会进行扩容操作。</span>    <span class="keyword">int</span> threshold;    <span class="comment">// 负载因子。</span>    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;    <span class="comment">// 参数为初始容量和负载因子的构造函数。</span>    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;    <span class="comment">// 判断初始化容量和负载因子的合法性</span>        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal initial capacity: &quot;</span> +                                               initialCapacity);        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)            initialCapacity = MAXIMUM_CAPACITY;        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal load factor: &quot;</span> +                                               loadFactor);        <span class="keyword">this</span>.loadFactor = loadFactor;<span class="comment">// 将容量调整为大于参数的最小2次方</span>        <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);    &#125;    <span class="comment">// 参数为初始容量的构造方法。</span>    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;        <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);    &#125;    <span class="comment">// 无参构造函数，会将负载因子设为默认的。</span>    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;        <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span>    &#125;    <span class="comment">// 参数为Map类型的构造函数</span>    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;        <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;        putMapEntries(m, <span class="keyword">false</span>);    &#125;        <span class="comment">// hashMap自带的hash函数。</span>    <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;        <span class="keyword">int</span> h;        <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);    &#125;</code></pre><p>首先讲解一些常量，可以看出来，HashMap容量大小默认是16，且必须是2的次方，这个原因后续会说。负载因子为0.75，也就是说HashMap中的元素达到容量的0.75就扩容，如==16*0.75=12==，那么容量使用达到12就会扩容。因此这个值<strong>太小了容易导致扩容频繁，非常消耗性能</strong>，太大了容易导致<strong>哈希冲突概率变大，链表变长，这样的话查找效率就低了</strong>。总之值的大小的优缺点是对立的，0.75是官方认为一个较为平衡的值。</p><p>至于变量，注释已经给出了相应的解释。</p><p>最后看下构造函数和hash方法，在所有的构造函数中，都会设置负载因子和初始化容量，如果用户没有给，那么就使用默认的，其中，初始化容量，即使用户给了非2的次方数，也会使用tableSize方法调整过来，比如传11，容量并不会就是11，而是16，传17，就会是32。始终保持2的次方。至于hash方法，又叫<strong>扰动函数</strong>，它能使hash的值分布的<strong>更随机</strong>，避免hash冲突太频繁。</p><h2 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h2><p>这次就不列增删改查了，直接从方法出发。</p><h3 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h3><pre><code class="highlight java"><span class="comment">// 调用了下面的方法</span>   <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;       <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);   &#125;   <span class="comment">/**</span><span class="comment">    * 真正执行put的方法</span><span class="comment">   */</span>   <span class="comment">// onlyIfAbsent为true时，不会改变已经存在的值，也就是说，只有key不存在时才会put。</span>   <span class="comment">// evict不用关心</span>   <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span><span class="function"><span class="params">                  <span class="keyword">boolean</span> evict)</span> </span>&#123;       Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;       <span class="comment">// 如果数组为null，或是长度为0，就进行扩容。</span>       <span class="comment">// 这意味着第一次put时就会进行扩容。</span>       <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)           n = (tab = resize()).length;       <span class="comment">// 如果key对应的那个位置为空，那么直接创建一个node放置便可。</span>       <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)           tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);       <span class="keyword">else</span> &#123; <span class="comment">// 否则，说明有hash冲突了。</span>           Node&lt;K,V&gt; e; K k;           <span class="comment">// p是这个数组的第一个节点，如果p和要插入的数据是一个值，那么将p赋值给e</span>           <span class="keyword">if</span> (p.hash == hash &amp;&amp;               ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))               e = p;           <span class="comment">// 否则，如果是红黑树的情况。调用红黑树查找，这里不描述红黑树的具体。</span>           <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)               e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);           <span class="keyword">else</span> &#123; <span class="comment">// 否则，是链表节点，那么顺着链表查找与插入的数相等的值。</span>               <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;              <span class="comment">// 如果没找到，就新建一个node节点，放在p后面。可以看出，这是尾插。</span>                   <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;                       p.next = newNode(hash, key, value, <span class="keyword">null</span>);                       <span class="comment">// 如果插入值之后是第八个节点，那么树形化。</span>                       <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span>                           treeifyBin(tab, hash);                       <span class="keyword">break</span>;                   &#125;                   <span class="comment">// 找到了，跳出循环。</span>                   <span class="keyword">if</span> (e.hash == hash &amp;&amp;                       ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))                       <span class="keyword">break</span>;                   p = e;               &#125;           &#125;           <span class="comment">// 如果e不为null，也就是说要插入的键值对中的key是存在。</span>           <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span>           <span class="comment">// 将旧的值取出</span>               V oldValue = e.value;               <span class="comment">// 如果onlyIfAbsent为false，或者旧值为null，将新的值覆盖</span>               <span class="comment">// (有关onlyIfAbsent的地方，方法开头已经写了)</span>               <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)                   e.value = value;               <span class="comment">// 这个不重要。</span>               afterNodeAccess(e);               <span class="keyword">return</span> oldValue;           &#125;       &#125;       <span class="comment">// 如果新增了node节点，就会modCount自增</span>       ++modCount;       <span class="comment">// 同时由于新增node，size也会自增，自增后超过阈值，也需要扩容。</span>       <span class="keyword">if</span> (++size &gt; threshold)           resize();       <span class="comment">// 这个也不重要。</span>       afterNodeInsertion(evict);       <span class="keyword">return</span> <span class="keyword">null</span>;   &#125;</code></pre><p>put方法还是比较好理解的。笼统概括一下。首先，如果是第一次put元素，那么就会先扩容，达到默认的16或者用户自定义的大小。然后使用(n - 1) &amp; hash进行取模运算，<strong>这个与运算和hash % n的效果是一样的，同时由于是位操作，因此会比%快</strong>。取模运算后看key的hash值是在数组的哪个位置，<strong>如果该位置上没有元素</strong>，那么直接新建一个node元素放在该位置上。否则说明数组上已经有元素了，那么首先判断该key是不是头结点，如果是，将头节点赋给e。如果不是，且头节点是红黑树的节点，那么走红黑树的查找。否则是链表，遍历链表，如果找到了，将节点赋给e。如果遍历了还是没有，就新建node节点放在链表尾部，此时，<strong>如果新增的元素刚好是第8个节点</strong>，那么树形化。最后，如果e的值不为null，说明key已经在map中存在了，覆盖然后返回旧值就行了，当然，<strong>onlyIfAbsent为true，且有旧值时是不能覆盖的。</strong>否则，要插入的键值对是新增的，那么增加<br>modCount，同时增加size，<strong>如果大于阈值，就扩容。</strong></p><h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><p>我们现在看看树形化的代码，<strong>这里有一个需要引起注意的地方</strong>。</p><pre><code class="highlight java"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;       <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;       <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)           resize();       <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;           TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;           <span class="keyword">do</span> &#123;               TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);               <span class="keyword">if</span> (tl == <span class="keyword">null</span>)                   hd = p;               <span class="keyword">else</span> &#123;                   p.prev = tl;                   tl.next = p;               &#125;               tl = p;           &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);           <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)               hd.treeify(tab);       &#125;   &#125;</code></pre><p>里面具体如何树形化的我就不解释了，但是可以看到该方法的开头， 如果数组为空，或者数组长度小于MIN_TREEIFY_CAPACITY(即64)，那么都会先扩容。</p><p><strong>也就是说！！！ 扩容的时机其实并不仅仅是数组大小大于阈值才会扩容，在树形化时如果数组大小没有达到64，也是会先扩容的！！！</strong></p><h4 id="总结一下put方法："><a href="#总结一下put方法：" class="headerlink" title="总结一下put方法："></a>总结一下put方法：</h4><ol><li>第一次put时，会导致扩容。</li><li>链表长为8时会树形化。</li><li>新增节点后，如果大于阈值，会导致扩容。</li><li>树形化时，如果数组大小没有达到默认的64，会先扩容，而不是树形化。<h3 id="resize方法"><a href="#resize方法" class="headerlink" title="resize方法"></a>resize方法</h3><pre><code class="highlight java"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;       Node&lt;K,V&gt;[] oldTab = table;       <span class="comment">// 旧的容量，如果是第一次扩容，旧容量就是0</span>       <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;       <span class="comment">// 旧的阈值</span>       <span class="keyword">int</span> oldThr = threshold;       <span class="comment">// 新的容量和阈值。</span>       <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;       <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;       <span class="comment">// 这块就是数组扩容，不多说。</span>           <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;               threshold = Integer.MAX_VALUE;               <span class="keyword">return</span> oldTab;           &#125;           <span class="comment">// 将数组扩容至2倍</span>           <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;                    oldCap &gt;= DEFAULT_INITIAL_CAPACITY)                <span class="comment">// 阈值也翻倍。</span>               newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span>       &#125;       <span class="comment">// 说明是第一次扩容，且使用了带参的构造方法，将阈值赋给新容量。</span>       <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>)            newCap = oldThr;       <span class="keyword">else</span> &#123; <span class="comment">// 说明是第一次扩容，使用的是无参的构造方法，那么使用系统默认的值</span>           newCap = DEFAULT_INITIAL_CAPACITY;           <span class="comment">// 这里可以看见，阈值等于负载因子 * 容量</span>           newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);       &#125;       <span class="comment">// 这里不解释了。</span>       <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;           <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;           newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?                     (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);       &#125;       <span class="comment">// 替换新阈值，同时初始化数组。</span>       threshold = newThr;       Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];       table = newTab;       <span class="comment">// 说明不是第一次扩容，需要遍历数组迁移元素。</span>       <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;           <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;               Node&lt;K,V&gt; e;               <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;                   oldTab[j] = <span class="keyword">null</span>;                   <span class="comment">// 如果该位置上只有一个元素，那么迁移这个元素就行了。</span>                   <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)                       newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;                   <span class="comment">// 如果该位置是红黑树，提一句，迁移数据之后，长度小于UNTREEIFY_THRESHOLD(即6),那么就会转回为链表</span>                   <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)                       ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);                   <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span>                       Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;                       Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;                       Node&lt;K,V&gt; next;                       <span class="comment">// 这个do-while是将数组分为两个链表，一个是与旧容量相与为1，一个是为0</span>                       <span class="keyword">do</span> &#123;                           next = e.next;                           <span class="comment">// 如果e的hash值与旧容量进行与运算后还是为0</span>                           <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;                           <span class="comment">// 如果loTail 为null，那么loHead指向e.</span>                               <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)                                   loHead = e;                               <span class="keyword">else</span>                                   loTail.next = e;                               loTail = e;                           &#125;                           <span class="keyword">else</span> &#123; <span class="comment">// 如果进行与运算为1</span>                               <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)                                   hiHead = e;                               <span class="keyword">else</span>                                   hiTail.next = e;                               hiTail = e;                           &#125;                       &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);                       <span class="comment">// 如果相与为0，那么待在原位置。</span>                       <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;                           loTail.next = <span class="keyword">null</span>;                           newTab[j] = loHead;                       &#125;                       <span class="comment">// 如果为1，则迁去新位置，这个新位置是原位置+原容量。</span>                       <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;                           hiTail.next = <span class="keyword">null</span>;                           newTab[j + oldCap] = hiHead;                       &#125;                   &#125;               &#125;           &#125;       &#125;       <span class="keyword">return</span> newTab;   &#125;</code></pre>扩容也是比较好理解的，记录旧的容量和旧的阈值。如果是第一次扩容，那么将容量设为默认的或者用户传来的。如果不是，将容量扩容至原来的两倍，同时，在这里可以看到阈值 = 负载因子 * 容量。</li></ol><p>如果不是第一次扩容，需要进行元素迁移。如果是链表的迁移，<strong>在扩容中只用判断原来的 hash 值与原容量按位与操作是 0 或 1 就行，0 的话索引就不变，1 的话索引变成原索引加上扩容前数组</strong>，这里为什么是这样解释一下，新容量的大小是原大小的两倍，之前当key判断自己应该在数组中的哪个位置时，使用的是(n - 1) &amp; hash，这里的n是指数组大小。那么元素迁移要判断自己位置时，也就是(新容量 - 1) &amp; hash，新容量-1和旧容量-1在二进制中只是多了最高位上的1，而这个1就是旧容量上的1，因此只要与旧容量进行&amp;运算就行。</p><p>可能文字解释的比较绕口。使用实例解释一下吧。</p><pre><code class="highlight java"><span class="comment">// 假设hash值是10101。</span><span class="comment">// oldSize是 10000.</span><span class="comment">// newSize就是 100000.</span><span class="comment">// (oldSize - 1) &amp; hash = 01111 &amp; 10101 = 00101.</span><span class="comment">// (newSize - 1) &amp; hash = 011111 &amp; 10101 = 10101.</span><span class="comment">// 可以看出newSize - 1比oldSize - 1只是多了1，而这个1的位置就是oldSize的1的位置，其他并没有变</span><span class="comment">// 因此在newSize是oldSize两倍的情况下，(newSize - 1) &amp; hash与oldSize &amp; hash的结果是一样的</span></code></pre><h3 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h3><pre><code class="highlight java"><span class="comment">// 调用下面的方法</span><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;       Node&lt;K,V&gt; e;       <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;   &#125;      <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;       Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;       <span class="comment">// 如果数组不为null，且长度不为空，且key的hash对应的数组位置不为null</span>       <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;           (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;           <span class="comment">// 如果第一个元素就是，直接返回第一个元素</span>           <span class="keyword">if</span> (first.hash == hash &amp;&amp;                ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))               <span class="keyword">return</span> first;           <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;           <span class="comment">// 如果是红黑树，用红黑树的方法。</span>               <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)                   <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);               <span class="comment">// 如果是链表，遍历，找到了就返回</span>               <span class="keyword">do</span> &#123;                   <span class="keyword">if</span> (e.hash == hash &amp;&amp;                       ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))                       <span class="keyword">return</span> e;               &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);           &#125;       &#125;       <span class="comment">// 没找到就返回null。</span>       <span class="keyword">return</span> <span class="keyword">null</span>;   &#125;</code></pre><p>get方法对比put和resize方法还是很简单的。这里不解释了。</p><pre><code class="highlight plain">在这里插入代码片</code></pre><h2 id="与1-7版本的对比"><a href="#与1-7版本的对比" class="headerlink" title="与1.7版本的对比"></a>与1.7版本的对比</h2><p>由于不会写1.7版本的hashMap源码，因此这里说一下两者之间的区别。</p><ul><li>首先，是结构上的区别。1.7的是数组+链表，1.8是数组+链表/红黑树。</li><li>其次，是数据上的区别。初始化时1.8是直接用resize方法的，1.7使用了额外的inflateTable方法。插入数据时，1.8使用的是尾插法，1.7是头插法。</li><li>最后，是扩容时的区别。<ol><li>1.8迁移元素使用的是hash值和原容量进行&amp;操作，新的位置一般在原位置或者原位置+原容量的位置上，而1.7还是使用的原来的方法，即先进行扰动处理，再进行(n - 1) &amp; hash，判断新位置在哪；</li><li>同时，1.8扩容还是使用的尾插法，而1.7扩容还是使用头插法，这样很容易导致环形链表死循环的情况；</li><li>1.8是先插入后判断是否需要扩容，1.7是先扩容再插入。</li></ol></li></ul><h2 id="与HashTable的对比"><a href="#与HashTable的对比" class="headerlink" title="与HashTable的对比"></a>与HashTable的对比</h2><p>HashTable其实现在很少用了，但还是提一下主要的区别吧。</p><ul><li>HashTable继承自Dictionary类，而HashMap继承自Map。</li><li>HashMap允许key和value为null的，HashTable则不行。</li><li>HashTable的所有方法都是加上了sychronized的，性能因此会比较低，而HashMap不是。<h2 id="总结一下（1-8版本）"><a href="#总结一下（1-8版本）" class="headerlink" title="总结一下（1.8版本）"></a>总结一下（1.8版本）</h2><ol><li>HashMap是基于数组+链表/红黑树的，HashMap有阈值，该阈值大小是由负载因子相乘容量大小决定的，一旦容量大于该阈值，就会导致扩容，同样的第一次put操作也会扩容。一旦链表长度达到8，就树形化为红黑树，<strong>如果此时数组长度大小小于默认的64，就会先扩容，而不是树形化。</strong></li><li>HashMap在添加元素和扩容时都是使用尾插法，而且是先插值后判断是否需要扩容。</li><li>HashMap是线程不安全的，在多线程并发访问时需要同步，可以使用替代的ConcurrentHashMap或者使用 Collections.synchronizedMap()修饰。</li></ol></li></ul><p>以上，是关于HashMap 1.8的全部内容。</p><p><strong>谢谢各位的观看。本人才疏学浅，如有错误之处，欢迎指正，共同进步。</strong></p>]]></content>
      
      
      <categories>
          
          <category> Java集合 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对Collections.synchronizedList的部分思考</title>
      <link href="2019/06/11/dui-collections.synchronizedlist-de-bu-fen-si-kao/"/>
      <url>2019/06/11/dui-collections.synchronizedlist-de-bu-fen-si-kao/</url>
      
        <content type="html"><![CDATA[<p>首先来看两个例子。</p><p>线程不安全的：</p><pre><code class="highlight java"><span class="class"><span class="keyword">class</span> <span class="title">ListHelper</span> &lt;<span class="title">E</span>&gt; </span>&#123;      <span class="keyword">public</span> List&lt;E&gt; list = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;E&gt;());      <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">putIfAbsent</span><span class="params">(E x)</span> </span>&#123;          <span class="keyword">boolean</span> absent = !list.contains(x);          <span class="keyword">if</span> (absent)              list.add(x);          <span class="keyword">return</span> absent;      &#125;  &#125;</code></pre><p>线程安全的：</p><pre><code class="highlight java"><span class="class"><span class="keyword">class</span> <span class="title">ListHelper</span> &lt;<span class="title">E</span>&gt; </span>&#123;      <span class="keyword">public</span> List&lt;E&gt; list = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;E&gt;());      <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">putIfAbsent</span><span class="params">(E x)</span> </span>&#123;          <span class="keyword">synchronized</span> (list) &#123;              <span class="keyword">boolean</span> absent = !list.contains(x);              <span class="keyword">if</span> (absent)                  list.add(x);              <span class="keyword">return</span> absent;          &#125;      &#125;  &#125;</code></pre><p>一开始很诧异为啥上面的线程不安全，下面的线程安全。<br>不过想通了就很好解释了，下面是我的思考：</p><p>这个方法的作用是，如果没有则添加，<strong>所以就必须保证list 这个变量的正确性。</strong></p><p>假设有一个线程A，一个线程B，都有同一个ListHelper 对象，锁住了putIfAbsent方法，乍一看是没什么问题的，但是仔细想想。sychronized获取到的只是这个ListHelper 对象的监视锁，假设线程A获取到了这个锁，那么线程B不能进入putIfAbsent方法是很正常的，可以理解的，但是假设这类中有一个其他的方法对list进行修改，且该方法并未被sychronized锁住，线程B是可以进入这个方法的，那么很明显，list没有可见性的，从而就会导致不正确性。那么这个sychronized是没起到保证list正确性的，因此是线程不安全的。</p><p><strong>也可以理解成因为A锁住的是外部锁，也就是调用putIfAbsent方法的对象，其实对list是没有锁住的，因此list还是可以修改。即使list是synchronizedList，是线程安全的，但内外部锁不一致还是会导致线程不安全。</strong></p><p>还有一个情况是，假设该list并没有被Collections.synchronizedList修饰的话，锁住的也只是list对象，也就是说，还是和上面差不多，因为ArrayList是线程不安全的，里面的方法并没有被sychronized修饰，这样的话就会导致还是可以在其他方法中修改该list的。</p><p><strong><em>当然，这两种情况不是同一种原因。</em></strong></p><p>但是使用了Collections.synchronizedList就不一样了。下面看一下源码：</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">synchronizedList</span><span class="params">(List&lt;T&gt; list)</span> </span>&#123;       <span class="keyword">return</span> (list <span class="keyword">instanceof</span> RandomAccess ?               <span class="keyword">new</span> SynchronizedRandomAccessList&lt;&gt;(list) :               <span class="keyword">new</span> SynchronizedList&lt;&gt;(list));   &#125;</code></pre><p>可以看到，实现了RandomAccess 接口的会返回一个SynchronizedRandomAccessList类，否则返回SynchronizedList类。由于ArrayList是实现了这个接口，因此看一下SynchronizedRandomAccessList这个类：</p><pre><code class="highlight java"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedRandomAccessList</span>&lt;<span class="title">E</span>&gt;</span><span class="class">       <span class="keyword">extends</span> <span class="title">SynchronizedList</span>&lt;<span class="title">E</span>&gt;</span><span class="class">       <span class="keyword">implements</span> <span class="title">RandomAccess</span> </span>&#123;       SynchronizedRandomAccessList(List&lt;E&gt; list) &#123;           <span class="keyword">super</span>(list);       &#125;       SynchronizedRandomAccessList(List&lt;E&gt; list, Object mutex) &#123;           <span class="keyword">super</span>(list, mutex);       &#125;       <span class="function"><span class="keyword">public</span> List&lt;E&gt; <span class="title">subList</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;           <span class="keyword">synchronized</span> (mutex) &#123;               <span class="keyword">return</span> <span class="keyword">new</span> SynchronizedRandomAccessList&lt;&gt;(                   list.subList(fromIndex, toIndex), mutex);           &#125;       &#125;       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1530674583602358482L</span>;              <span class="function"><span class="keyword">private</span> Object <span class="title">writeReplace</span><span class="params">()</span> </span>&#123;           <span class="keyword">return</span> <span class="keyword">new</span> SynchronizedList&lt;&gt;(list);       &#125;   &#125;</code></pre><p>会发现这个类继承自SynchronizedList，然后subList方法中使用mutex监视器锁（其实每个方法都会锁住mutex，只是这里没贴出来），但是这个mutex并没有在其中定义，这时来看看构造方法：</p><pre><code class="highlight java">SynchronizedRandomAccessList(List&lt;E&gt; list, Object mutex) &#123;          <span class="keyword">super</span>(list, mutex);      &#125;</code></pre><p>这里有个mutex变量，点进去看，会发现该变量定义在SynchronizedCollection中，那么再来看一下SynchronizedCollection的部分代码：</p><pre><code class="highlight java"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedCollection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt;, <span class="title">Serializable</span> </span>&#123;       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">3053995032091335093L</span>;       <span class="keyword">final</span> Collection&lt;E&gt; c;  <span class="comment">// Backing Collection</span>       <span class="keyword">final</span> Object mutex;     <span class="comment">// Object on which to synchronize</span>       SynchronizedCollection(Collection&lt;E&gt; c) &#123;           <span class="keyword">this</span>.c = Objects.requireNonNull(c);           mutex = <span class="keyword">this</span>;       &#125;   &#125;</code></pre><p>可以看到这里定义了变量mutex，同时这个mutex在构造方法中赋值为this。<strong>因此，在线程安全的ListHelper 中锁住的list，与内部锁一致，其他的方法即使没有锁修饰，但是想改动list也会发现它已经被锁住，而无法修改，因此是线程安全的。</strong></p><p>通过上面的源码，就可以知道线程安全的ListHelper 安全在哪了，使用之前对线程不安全的ListHelper 分析来线程安全的ListHelper ，会发现之前线程不安全的原因在这个类中不存在了。</p><p>以上，就是我对Collections.synchronizedList的部分思考，如有错误，欢迎指教。</p>]]></content>
      
      
      <categories>
          
          <category> Java集合 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java集合 </tag>
            
            <tag> Java并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ConcurrentHashMap源码解析（基于1.8版本）</title>
      <link href="2019/05/10/concurrenthashmap-yuan-ma-jie-xi-ji-yu-1.8-ban-ben/"/>
      <url>2019/05/10/concurrenthashmap-yuan-ma-jie-xi-ji-yu-1.8-ban-ben/</url>
      
        <content type="html"><![CDATA[<p>ConcurrentHashMap（以下简称chm）是concurrent包下的用于多线程并发的一个类，由Doug Lea大神编写。它比HashMap更复杂（<del>其实HashMap也没有很复杂</del> ），它是线程安全的同时效率还比HashTable高。</p><p>首先，1.8的CHM和1.7是有很大的区别的，1.8的CHM结构上和HashMap1.8一样，<strong>也是数组+链表/红黑树</strong>，但是由于支持并发访问，因此源码是比HashMap复杂许多的。1.7和1.8的CHM还有其他区别现在就先不说了，以后会写的。</p><p>再有，给个前提。CHM1.8是采用了 CAS + synchronized 来保证并发安全性（关于CAS和synchronized以后会也写相关的文章的）。带着这个前提去看可能更能理解一点。</p><p><strong>注：虽然是源码解析，但是并不是所有的源码都会涉及到，只涉及到经常使用的那些。同时，也不是所有的都会解释的很清楚，还得自己亲自去看，那才会是自己的。</strong></p><h2 id="常用常量和变量"><a href="#常用常量和变量" class="headerlink" title="常用常量和变量"></a>常用常量和变量</h2><p>先来看一些常量。</p><pre><code class="highlight java"><span class="comment">// chm能接受的最大的容量</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;<span class="comment">// 默认的初始化容量</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">16</span>;<span class="comment">// 能转成array最大的阈值。</span><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;<span class="comment">// 默认能支持的并发数量。</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="number">16</span>;<span class="comment">// 负载因子，扩容时使用。</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> LOAD_FACTOR = <span class="number">0.75f</span>;<span class="comment">// 树形化的阈值</span><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;<span class="comment">// 红黑树转回链表的阈值。</span><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;<span class="comment">// 如果没达到这个容量，会先扩容，而不是树形化。这样避免调整大小和树形化冲突。</span><span class="comment">// 这个值一般最少是4 * TREEIFY_THRESHOLD</span><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TRANSFER_STRIDE = <span class="number">16</span>;<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> RESIZE_STAMP_BITS = <span class="number">16</span>;<span class="comment">// 帮助扩容的最大线程数。</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_RESIZERS = (<span class="number">1</span> &lt;&lt; (<span class="number">32</span> - RESIZE_STAMP_BITS)) - <span class="number">1</span>;<span class="comment">// sizeCtl中记录size大小的偏移量，为16</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESIZE_STAMP_SHIFT = <span class="number">32</span> - RESIZE_STAMP_BITS;<span class="comment">// node的hash值。</span><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOVED     = -<span class="number">1</span>; <span class="comment">// forwarding nodes的hash值</span><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEBIN   = -<span class="number">2</span>; <span class="comment">// 树的根节点hash值</span><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESERVED  = -<span class="number">3</span>; <span class="comment">// 暂时保留的hash值</span></code></pre><p>常用变量如下：</p><pre><code class="highlight java"><span class="comment">// CHM的数组，通常到第一次插入时才被初始化，大小总是为2的次方</span><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;<span class="comment">// 扩容时的新数组。</span><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;<span class="comment">// 基础计数器。</span><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">long</span> baseCount;<span class="comment">// 控制数组初始化以及扩容阈值的变量。</span><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl;</code></pre><p>有一些HashMap中有的就不说了，如负载因子，树形化阈值等。<br>这里只讲解一个变量，sizeCtl，它是用于控制数组初始化以及扩容的变量，它的值不同代表着不同的意思：</p><ol><li>为-1时，表示正在初始化中。</li><li>为-n时，表示有(n - 1)个线程帮助扩容。</li><li>为0或是正值时，表示还没有初始化，那么这个值就表示初始化或是下次扩容的大小。</li></ol><p> <strong>可以看见sizeCtl为负数时，不是在初始化就是在扩容。</strong><br>最后，需要引起注意的是，<strong>所有的变量都使用volatile修饰</strong>了！！volatile是保证了可见性的。</p><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>无参的就不放上来了，就看几个有参的构造函数吧。</p><pre><code class="highlight java"><span class="comment">// 给了初始化容量。</span><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;       <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();       <span class="comment">// 给cap赋值为大于等于（1.5倍initialCapacity + 1）的2次方的数</span>       <span class="keyword">int</span> cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ?                  MAXIMUM_CAPACITY :                  tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>));       <span class="comment">// 将cap赋值给sizeCtl</span>       <span class="keyword">this</span>.sizeCtl = cap;   &#125;   <span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;       <span class="keyword">this</span>.sizeCtl = DEFAULT_CAPACITY;       putAll(m);   &#125;   <span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;       <span class="keyword">this</span>(initialCapacity, loadFactor, <span class="number">1</span>);   &#125;   <span class="comment">// 给了初始化容量，负载因子，并发数的。</span>   <span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span><span class="function"><span class="params">                            <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;       <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0.0f</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();       <span class="keyword">if</span> (initialCapacity &lt; concurrencyLevel)   <span class="comment">// Use at least as many bins</span>           initialCapacity = concurrencyLevel;   <span class="comment">// as estimated threads</span>       <span class="keyword">long</span> size = (<span class="keyword">long</span>)(<span class="number">1.0</span> + (<span class="keyword">long</span>)initialCapacity / loadFactor);       <span class="keyword">int</span> cap = (size &gt;= (<span class="keyword">long</span>)MAXIMUM_CAPACITY) ?           MAXIMUM_CAPACITY : tableSizeFor((<span class="keyword">int</span>)size);       <span class="keyword">this</span>.sizeCtl = cap;   &#125;</code></pre><p>构造函数做个了解就行，一般都是使用无参的构造函数。有一个地方需要引起注意，就是使用tableSizeFor方法时，传递的是<br>1.5 * initialCapacity + 1，也就是说，如果你的initialCapacity是10，那么真正的大小是16，如果传的是11，那么真正大小是32。这里和HashMap1.8是不一样的。</p><h2 id="常用api"><a href="#常用api" class="headerlink" title="常用api"></a>常用api</h2><h3 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h3><pre><code class="highlight java"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;       <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);   &#125;   <span class="comment">// onlyIfAbsent为true时，不会改变已经存在的值，也就是说，只有key不存在时才会put。</span>   <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;       <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();       <span class="comment">// 得到hash值</span>       <span class="keyword">int</span> hash = spread(key.hashCode());       <span class="comment">// 记录链表长度</span>       <span class="keyword">int</span> binCount = <span class="number">0</span>;       <span class="comment">// 遍历数组</span>       <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;           Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;           <span class="comment">// 没有初始化数组就先初始化</span>           <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)               tab = initTable();           <span class="comment">// 判断该key落在数组的哪个位置，然后将第一个节点赋值给f。</span>           <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;           <span class="comment">// 如果该节点为null</span>           <span class="comment">// 通过cas将该节点放置到该位置</span>               <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,                            <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))                   <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span>           &#125;           <span class="comment">// 如果f的hash值为MOVED（-1），那么帮助扩容</span>           <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)               tab = helpTransfer(tab, f);           <span class="keyword">else</span> &#123; <span class="comment">// 如果不是，那就将插入</span>               V oldVal = <span class="keyword">null</span>;               <span class="keyword">synchronized</span> (f) &#123; <span class="comment">// 使用sychronized锁住头节点。</span>               <span class="comment">// 再判断头节点是否是f。</span>                   <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;                   <span class="comment">// 如果头节点的hash值大于0，说明是链表</span>                       <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;                       <span class="comment">// 记录链表长度的，因为进来了说明头节点肯定不为null，因此赋值为1</span>                           binCount = <span class="number">1</span>;                           <span class="comment">// 遍历链表</span>                           <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;                               K ek;                               <span class="comment">// 如果hash值相等，同时key值一样，或是key值相等。</span>                               <span class="keyword">if</span> (e.hash == hash &amp;&amp;                                   ((ek = e.key) == key ||                                    (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;                                   oldVal = e.val;                                   <span class="comment">// 判断能否覆盖，能就覆盖了。</span>                                   <span class="keyword">if</span> (!onlyIfAbsent)                                       e.val = value;                                   <span class="keyword">break</span>;                               &#125;                               Node&lt;K,V&gt; pred = e;                               <span class="comment">// 已经到链表末尾了，将节点插入到最后</span>                               <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;                                   pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,                                                             value, <span class="keyword">null</span>);                                   <span class="keyword">break</span>;                               &#125;                           &#125;                       &#125;                       <span class="comment">// 如果是红黑树的</span>                       <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;                           Node&lt;K,V&gt; p;                           binCount = <span class="number">2</span>;                           <span class="comment">// 使用红黑树的方法插入进红黑树</span>                           <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,                                                          value)) != <span class="keyword">null</span>) &#123;                               oldVal = p.val;                               <span class="keyword">if</span> (!onlyIfAbsent)                                   p.val = value;                           &#125;                       &#125;                   &#125;               &#125;               <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;               <span class="comment">// 如果链表长度大于树形化的阈值，那么就树形化。</span>                   <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)                   <span class="comment">// 这里和HashMap1.8是一样的，如果数组大小小于64，那么会先进行扩容而不是树形化</span>                       treeifyBin(tab, i);                   <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)                       <span class="keyword">return</span> oldVal;                   <span class="keyword">break</span>;               &#125;           &#125;       &#125;       <span class="comment">// 将大小（即baseCount）+1</span>       addCount(<span class="number">1L</span>, binCount);       <span class="keyword">return</span> <span class="keyword">null</span>;   &#125;</code></pre><p>一路看下来，put方法其实也不难，梳理一下流程。</p><ol><li><p>首先拿到key的hash值，然后看数组是否初始化，没有的话，先初始化。</p></li><li><p>判断hash值应该在数组中的哪个位置，如果该位置上没有任何节点，使用cas插入即可。</p></li><li><p>如果已经有节点，判断该节点的hash值是否等于MOVED，该值表示正在扩容，因此，如果是，那么帮助扩容。如果不等于，那么使用sychronized获取头节点的监视器锁。避免多个线程并发插入。</p></li><li><p>判断数组中是链表还是红黑树， 然后遍历，如果已经有该节点，那么判断能否覆盖，再决定是否覆盖。</p></li><li><p>如果没有，则使用尾插法（如果是链表）插入到末尾。</p></li><li><p>最后，判断是否需要树形化。当然，<strong>在树形化之前会先判断数组大小是否小于64，如果小于，会先扩容而不是树形化。</strong></p><p>这里有几个方法还没写到，初始化数组，扩容，以及数据迁移。不过后面都会提到的。</p></li></ol><h3 id="initTable-方法"><a href="#initTable-方法" class="headerlink" title="initTable 方法"></a>initTable 方法</h3><p>该方法的作用是初始化数组的。</p><pre><code class="highlight java"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;       Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;       <span class="comment">// 当数组为空，或是长度为0时</span>       <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;       <span class="comment">// 如果sizeCtl 的值为负值，说明正在初始化，那么线程让步。</span>           <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)               Thread.yield(); <span class="comment">// lost initialization race; just spin</span>           <span class="comment">// 如果不是为负值，那么通过cas将sizeCtl值设为-1</span>           <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;               <span class="keyword">try</span> &#123;               <span class="comment">// 再次判断是否未初始化或是长度为0</span>                   <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;                   <span class="comment">// 如果sizeCtl大于0，那么设置为传来的值，否则为默认值，16.</span>                       <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;                       <span class="comment">// 新建一个数组，长度为16或是传来的值</span>                       Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];                       <span class="comment">// 将新建的数组传给变量table，该table是volatile的。</span>                       table = tab = nt;                       <span class="comment">// 将sc的值设为n的0.75倍。</span>                       <span class="comment">// 如果n一开始默认是16的话，那么这里sc就是12.</span>                       sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);                   &#125;               &#125; <span class="keyword">finally</span> &#123;               <span class="comment">// 将sc的值赋给sizeCtl </span>                   sizeCtl = sc;               &#125;               <span class="keyword">break</span>;           &#125;       &#125;       <span class="keyword">return</span> tab;   &#125;</code></pre><p>初始化方法比较简单，简而言之，就是先判断数组是否已经初始化，同时sizeCtl是否是负数了，如果已经是负数了说明已经有线程在初始化，那么直接让步就行。如果不是，说明还没有线程初始化，这个时候正在执行的线程就可以通过cas将sizeCtl设为-1，表示自己已经在初始化了，cas成功之后，还需要判断一次是否已经初始化，因为很有可能轮到当前线程cas成功进入之后，其实已经有线程初始化完成了。</p><p>下面看看重头戏，扩容。</p><h3 id="扩容方法"><a href="#扩容方法" class="headerlink" title="扩容方法"></a>扩容方法</h3><h3 id="addCount方法"><a href="#addCount方法" class="headerlink" title="addCount方法"></a>addCount方法</h3><p>更新baseCount大小，同时判断是否需要扩容。</p><pre><code class="highlight java"><span class="comment">// 将baseCount大小+x</span><span class="comment">// x是要加的大小</span><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">int</span> check)</span> </span>&#123;       CounterCell[] as; <span class="keyword">long</span> b, s;       <span class="comment">// 如果通过cas+1失败，执行下面的方法。这里不细讲了。</span>       <span class="keyword">if</span> ((as = counterCells) != <span class="keyword">null</span> ||           !U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;           CounterCell a; <span class="keyword">long</span> v; <span class="keyword">int</span> m;           <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;           <span class="keyword">if</span> (as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||               (a = as[ThreadLocalRandom.getProbe() &amp; m]) == <span class="keyword">null</span> ||               !(uncontended =                 U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;               fullAddCount(x, uncontended);               <span class="keyword">return</span>;           &#125;           <span class="keyword">if</span> (check &lt;= <span class="number">1</span>)               <span class="keyword">return</span>;           s = sumCount();       &#125;       <span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;           Node&lt;K,V&gt;[] tab, nt; <span class="keyword">int</span> n, sc;           <span class="comment">// 如果大小+x之后大于扩容阈值，那么就执行是否扩容操作。</span>           <span class="comment">// 由于这个方法和tryPresize方法类似，直接看下面的。</span>           <span class="keyword">while</span> (s &gt;= (<span class="keyword">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="keyword">null</span> &amp;&amp;                  (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;               <span class="keyword">int</span> rs = resizeStamp(n);               <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;                   <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||                       sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||                       transferIndex &lt;= <span class="number">0</span>)                       <span class="keyword">break</span>;                   <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))                       transfer(tab, nt);               &#125;               <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,                                            (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))                   transfer(tab, <span class="keyword">null</span>);               s = sumCount();           &#125;       &#125;   &#125;</code></pre><p>addCount方法过一下就行，在判断sc &lt; 0下的逻辑在tryPresize方法后面会详细讲解。</p><h4 id="tryPresize方法"><a href="#tryPresize方法" class="headerlink" title="tryPresize方法"></a>tryPresize方法</h4><pre><code class="highlight java"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">tryPresize</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;<span class="comment">// c的值为大于等于size的1.5倍+1的2次方。表示要扩容的大小。</span>       <span class="keyword">int</span> c = (size &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ? MAXIMUM_CAPACITY :           tableSizeFor(size + (size &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>);       <span class="keyword">int</span> sc;       <span class="comment">// 当sizeCtl的值大于等于0，表示没有线程在扩容。</span>       <span class="keyword">while</span> ((sc = sizeCtl) &gt;= <span class="number">0</span>) &#123;       <span class="comment">// tab赋值为table。</span>           Node&lt;K,V&gt;[] tab = table; <span class="keyword">int</span> n;           <span class="comment">// 这块和初始化数组基本上来说是一样的，就不再阐述了。</span>           <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>) &#123;               n = (sc &gt; c) ? sc : c;               <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;                   <span class="keyword">try</span> &#123;                       <span class="keyword">if</span> (table == tab) &#123;                           Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];                           table = nt;                           sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);                       &#125;                   &#125; <span class="keyword">finally</span> &#123;                       sizeCtl = sc;                   &#125;               &#125;           &#125;           <span class="comment">// 如果要扩容的大小小于扩容阈值，或者当前数组大小已经大于最大时，不扩容。</span>           <span class="keyword">else</span> <span class="keyword">if</span> (c &lt;= sc || n &gt;= MAXIMUM_CACTY)               <span class="keyword">break</span>;           <span class="comment">// 如果tab还是等于table的话。</span>           <span class="keyword">else</span> <span class="keyword">if</span> (tab == table) &#123;           <span class="comment">// n是当前数组长度，该方法返回n的生成戳</span>           <span class="comment">// resizeStamp会返回格式为0000 0000 0000 0000 1xxx xxx xxxx xxxx的数。</span>           <span class="comment">// 请注意，这个数的第17位必定是1，也就是说左移16位，必定是个负数。</span>               <span class="keyword">int</span> rs = resizeStamp(n);                              <span class="comment">//那就说明已经有线程在扩容了。</span>               <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;                   Node&lt;K,V&gt;[] nt;                                      <span class="comment">// 不参与扩容的条件</span>                   <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||                       sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||                       transferIndex &lt;= <span class="number">0</span>)                       <span class="keyword">break</span>;                   <span class="comment">// 否则参与进去。</span>                   <span class="comment">// 其实如果看后面，也就是transfer方法中，每参与一个，sizeCtl值就会+1，表示多一个线程参与进来。</span>                   <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))                       transfer(tab, nt);               &#125;               <span class="comment">// 如果sc大于等于0，表示目前还没有扩容的线程。</span>               <span class="comment">// 通过cas将sizeCtl的值设为(rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2</span>               <span class="comment">// 上面我们知道rs的第17位是1，因此，左移16位，必定是个负数，还是个蛮大的负数。</span>               <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,                                            (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))                   transfer(tab, <span class="keyword">null</span>);           &#125;       &#125;   &#125;</code></pre><p>这里的代码确实比较复杂，CHM1.8难就难在理解扩容这块。但是慢慢去体会，去思考，还是可以理解的，毕竟代码也是人写的。由于已经在注释中写的很清楚了，这里就不再赘述了。<strong>不过还是有几个点可能比较绕，有点让人无法理解，因此在这里详细说明一下</strong>。</p><ul><li>resizeStamp(n) 方法有两个作用：<ol><li> 计算出n的前导0的个数假设作为m，由于每个n的前导0个数肯定是不一样的，因此，<strong>m就是一个n的印记</strong>。</li><li>使m的第17位（从1开始计算的）为1，然后返回给 rs，因此，rs就形如是0000 0000 0000 0000 1xxx xxx xxxx xxxx的数。</li></ol></li><li>可以看见，在进入transfer(tab, null)方法之前，会将sizeCtl设为(rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2， <strong>由于rs 的第17位为1，因此左移16位，会使得sizeCtl 必定是一个负数，是负数就代表必定有线程在扩容了，同时由于左移16位了，sizeCtl 的高16位表示了这个线程是在扩容数组大小为 n 的！！</strong></li><li>有了上面的前提，那么，在进入了判断条件为 sc &lt; 0 的一连串判断就比较好理解了。<ol><li> (sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs， sc 无符号右移如果不等于 rs， 即 sc 的高16 位与 rs 不等，因此说明，印记不一样，就说明不是同一个容量的扩容操作，因此，不参与扩容。</li><li>sc== rs + 1和 sc== rs + MAX_RESIZERS ，就是判断帮助迁移的线程数是不是已经达到了运行帮助迁移的最大线程数。是，该线程肯定就不再帮助了。</li><li>(nt = nextTable) == null和transferIndex &lt;= 0说明已经迁移完成了，那肯定不用该线程再去帮忙。</li></ol></li><li>最后一个问题可能是，为什么第一个数据迁移的线程要将sizeCtl设为(rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2，rs &lt;&lt; RESIZE_STAMP_SHIFT的原因前面已经说过了，至于+2 ，<strong>是使sizeCtl低16位代表有多少个线程在进行数据迁移，由于sizeCtl == -1 表示的是正在初始化，所以 +2 ，同时也代表了有一个线程已经在数据迁移了。</strong>，前面也说过sizeCtl为-n时，表示有(n - 1)个线程帮助扩容。</li></ul><p><strong><em>不过这里我有一个疑惑，就是按理应该不可能进入if (sc &lt; 0) 中的，因为while循环的条件就是(sc = sizeCtl) &gt;= 0，而sc又不是由volatile修饰的，不存在可见性的可能，希望有知道的人告知一声，谢谢。</em></strong></p><h4 id="transfer方法"><a href="#transfer方法" class="headerlink" title="transfer方法"></a>transfer方法</h4><p>重头戏来了，数据迁移方法。可能直接看源码有点难，我先来讲解一下前提，带着这个前提去理解就会好很多。</p><p>数据迁移，就是类似HashMap一样将原数组的数据迁移到新数组中去，但是由于CHM要保证线程安全性的同时还要保证一定的效率，因此，做了很多的工作。</p><p>首先，假设原数组大小为n，那么就有n个要迁移的数据任务（不是说要迁移的节点只有N个，而是每个数组中的链表/红黑树算一个任务），然后让多个线程负责这些小任务，==<strong>每个线程需要负责的小任务数量用stride表示</strong>==，这样就能达到多个线程同时迁移数据的目的。</p><p>可想而知，如果要知道线程要处理从哪里开始的小任务，那肯定要有一个全局性的变量去控制，任务分配到了哪个位置，这样才能让A（或其他线程）知道应该从哪处理。transferIndex就是这个全局性的变量。</p><p>同时，还要知道，从下面的源码可以看出，transferIndex最开始是赋值为数组大小的，==<strong>因此，说明是从后往前迁移的</strong>==。</p><pre><code class="highlight java"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> </span>&#123;       <span class="keyword">int</span> n = tab.length, stride;       <span class="comment">// 如果单核情况下stride 直接为n，如果是多核情况下就是(n &gt;&gt;&gt; 3) / NCPU</span>       <span class="comment">// 但是stride 最小为16，说明一个线程最少处理16个小任务。</span>       <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)           stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range</span>       <span class="comment">// 新数组还未初始化</span>       <span class="keyword">if</span> (nextTab == <span class="keyword">null</span>) &#123;            <span class="comment">// initiating</span>           <span class="keyword">try</span> &#123;               <span class="comment">// 创建一个新数组，大小为当前数组大小的2倍。</span>               Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];               nextTab = nt;           &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span>               sizeCtl = Integer.MAX_VALUE;               <span class="keyword">return</span>;           &#125;           <span class="comment">// 将创建的新数组赋值给nextTable </span>           nextTable = nextTab;           <span class="comment">// transferIndex 指向原数组的最后一个位置,说明数据迁移是从后向前的。</span>           transferIndex = n;       &#125;       <span class="keyword">int</span> nextn = nextTab.length;              <span class="comment">// ForwardingNode，就是之前常量中提到的MOVED的那个！！！</span>       <span class="comment">// 这个ForwardingNode表示正在迁移的节点！！hash值为MOVED，也就是-1。</span>       <span class="comment">// 也就是在putVal如果头节点的hash值为MOVED就调用helpTransfer帮助数据迁移！！！</span>       ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> ForwardingNode&lt;K,V&gt;(nextTab);              <span class="comment">// 表示true说明已经做过了数据迁移，可以做其他的小任务了。</span>       <span class="comment">// 其实从advance翻译也看的出来，前进的意思。</span>       <span class="keyword">boolean</span> advance = <span class="keyword">true</span>;       <span class="comment">// 表示是否已数据迁移完成。</span>       <span class="keyword">boolean</span> finishing = <span class="keyword">false</span>; <span class="comment">// to ensure sweep before committing nextTab</span>       <span class="comment">/**</span><span class="comment">       *  由于是从后向前迁移的，i表示迁移开始的地方，bound 表示迁移的边界</span><span class="comment">       **/</span>       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;           Node&lt;K,V&gt; f; <span class="keyword">int</span> fh;           <span class="comment">// 前面也说了为true是说明已经做过迁移了，因此一直找下一个位置需要迁移的位置，直到找到为止。</span>           <span class="comment">// 想想看，刚进来的线程是不是什么任务都没做，因此，它可以接任务了。</span>           <span class="keyword">while</span> (advance) &#123;               <span class="keyword">int</span> nextIndex, nextBound;                <span class="comment">// </span>               <span class="keyword">if</span> (--i &gt;= bound || finishing)                   advance = <span class="keyword">false</span>;               <span class="comment">// 将下个要迁移的位置设为nextIndex </span>               <span class="comment">// 如果 &lt;= 0，说明数据已经迁移全部完了，不用迁移了。</span>               <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;                   i = -<span class="number">1</span>;                   advance = <span class="keyword">false</span>;               &#125;               <span class="comment">// 否则，说明还是有数据要迁移的，那么判断nextIndex的位置是否是大于stride。</span>               <span class="comment">// 是，则transferIndex改为nextIndex - stride</span>               <span class="comment">// 为什么判断是否大于stride，因为前面也说了，每个线程处理的小任务数以stride 起步的。</span>               <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt                        (<span class="keyword">this</span>, TRANSFERINDEX, nextIndex,                         nextBound = (nextIndex &gt; stride ?                                      nextIndex - stride : <span class="number">0</span>))) &#123;                   <span class="comment">// 将bound 设为迁移任务的边界</span>                   bound = nextBound;                   i = nextIndex - <span class="number">1</span>;                   advance = <span class="keyword">false</span>;               &#125;           &#125;           <span class="comment">// </span>           <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;               <span class="keyword">int</span> sc;               <span class="keyword">if</span> (finishing) &#123;               <span class="comment">// 到这里了表示已全部迁移完成，做一些相应的操作就可以直接return了。</span>                   nextTable = <span class="keyword">null</span>;                   table = nextTab;                   <span class="comment">// 将下次的扩容阈值设为新数组大小的0.75倍</span>                   sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);                   <span class="keyword">return</span>;               &#125;               <span class="comment">/**</span><span class="comment">               *  前情提示：</span><span class="comment">               *  在tryPresize中sizeCtl的值设为(rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2，rs就是resizeStamp(n)</span><span class="comment">               *  然后每有一个线程参与进来，sizeCtl就+1。</span><span class="comment">               *  因此，到了这里，又将sizeCtl-1了。</span><span class="comment">               **/</span>               <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;               <span class="comment">// </span>                   <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)                       <span class="keyword">return</span>;                                          <span class="comment">// 到了这里，说明(sc - 2) 肯定是等于resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT的</span>                   <span class="comment">// 也就是说，所有参与进来的线程都完成了自己的任务了。</span>                   <span class="comment">// 然后就可以进上面的if (finishing)方法了！</span>                   finishing = advance = <span class="keyword">true</span>;                   i = n; <span class="comment">// recheck before commit</span>               &#125;           &#125;           <span class="comment">// 否则，找到数组中的i位置，如果该位为null，那么将之前的ForwardingNode放过来。</span>           <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="keyword">null</span>)               advance = casTabAt(tab, i, <span class="keyword">null</span>, fwd);           <span class="comment">// 否则，表示已迁移过了。</span>           <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)               advance = <span class="keyword">true</span>; <span class="comment">// already processed</span>           <span class="keyword">else</span> &#123; <span class="comment">// 到这里就是表示进入的该线程终于可以迁移了！！！</span>           <span class="comment">// 使用sychronized获取头节点的监视器锁。</span>               <span class="keyword">synchronized</span> (f) &#123;               <span class="comment">// 再次判断头节点是否相等，因为有可能又有线程抢在你前面迁移数据了。</span>                   <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;                       Node&lt;K,V&gt; ln, hn;                       <span class="comment">// 如果是链表，走这里。</span>                       <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;                       <span class="comment">/** </span><span class="comment">                       * 将当前节点和 n(数组大小) 相与，这里的原理和HashMap是一样的。</span><span class="comment">                       * 如果和 n 相与为0，说明在新数组中的位置没变，如果是1，则新位置为原位置+n</span><span class="comment">                       * 因此，在原位置上的是一条链表，在原位置+n的又是一条链表。</span><span class="comment">                       **/</span>                       <span class="comment">// 拿到头节点和 n 的相与值</span>                           <span class="keyword">int</span> runBit = fh &amp; n;                           Node&lt;K,V&gt; lastRun = f;                           <span class="comment">// 拿到最后一个</span>                           <span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="keyword">null</span>; p = p.next) &#123;                               <span class="keyword">int</span> b = p.hash &amp; n;                               <span class="keyword">if</span> (b != runBit) &#123;                                   runBit = b;                                   lastRun = p;                               &#125;                           &#125;                           <span class="comment">// ln 代表的是在新数组原位置的，hn则是另一个的。</span>                           <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;                               ln = lastRun;                               hn = <span class="keyword">null</span>;                           &#125;                           <span class="keyword">else</span> &#123;                               hn = lastRun;                               ln = <span class="keyword">null</span>;                           &#125;                           <span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;                               <span class="keyword">int</span> ph = p.hash; K pk = p.key; V pv = p.val;                               <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)                                   ln = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, ln);                               <span class="keyword">else</span>                                   hn = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, hn);                           &#125;                           setTabAt(nextTab, i, ln);                           setTabAt(nextTab, i + n, hn);                           <span class="comment">// 将原数组该位置设置为fwd的。</span>                           <span class="comment">// 看上面也知道，其他线程看到了就知道已经有线程处理过这个了。</span>                        setTabAt(tab, i, fwd);                        advance = <span class="keyword">true</span>;                       &#125;                       <span class="comment">// 红黑树的数据迁移，这里不细讲了，和上面差不多。</span>                       <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;                           TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;                           TreeNode&lt;K,V&gt; lo = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;                           TreeNode&lt;K,V&gt; hi = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;                           <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;                           <span class="keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="keyword">null</span>; e = e.next) &#123;                               <span class="keyword">int</span> h = e.hash;                               TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> TreeNode&lt;K,V&gt;                                   (h, e.key, e.val, <span class="keyword">null</span>, <span class="keyword">null</span>);                               <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123;                                   <span class="keyword">if</span> ((p.prev = loTail) == <span class="keyword">null</span>)                                       lo = p;                                   <span class="keyword">else</span>                                       loTail.next = p;                                   loTail = p;                                   ++lc;                               &#125;                               <span class="keyword">else</span> &#123;                                   <span class="keyword">if</span> ((p.prev = hiTail) == <span class="keyword">null</span>)                                       hi = p;                                   <span class="keyword">else</span>                                       hiTail.next = p;                                   hiTail = p;                                   ++hc;                               &#125;                           &#125;                           ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :                               (hc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(lo) : t;                           hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :                               (lc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hi) : t;                           setTabAt(nextTab, i, ln);                           setTabAt(nextTab, i + n, hn);                           setTabAt(tab, i, fwd);                           advance = <span class="keyword">true</span>;                       &#125;                   &#125;               &#125;           &#125;       &#125;   &#125;</code></pre><p>其实要说的已经在前提和注释中说的很清楚了，但是还是简单的概括一下吧。</p><ol><li>首先stride最少是16，也就是说每个线程处理的小任务数最少是16的。</li><li>如果nextTable为null，就说明进来的这个线程是参与数据迁移的第一个，因此它比其他的线程多了一个初始化任务。</li><li>新建一个ForwardingNode节点，真正迁移数据时，这个节点会放在数组的头节点处，<strong>这个节点的hash值为MOVED（即-1），是一个标志性的存在，告知其它进来的线程，这个位置已经处理过了。同时，回看putVal的代码，如果获取的头节点的hash值是MOVED的，那么就会调用helpTransfer方法来参与进扩容这一步！</strong></li><li>进入while循环直到找到还没有进行迁移的位置，让人如果已经没有还需要迁移的，肯定就跳出来。</li><li>跳出while循环后，说明要么任务已经全分配出去了，要么就找到分配给这个线程任务的位置了，那么首先判断是不是已经全部分配且迁移完了，如果是就用新数组替换老数组同时将sizeCtl阈值设为新数组大小的0.75倍，也就是阈值。</li><li>如果不是，那么判断要迁移的位置上的头节点是否为空或者已经设为MOVED，代表已迁移了。那就继续走while循环找新的任务，直到找到可以迁移的位置。</li><li>找到后，就可以真正进行迁移了，会根据该位置上头节点的hash值判断是红黑树还是链表再放到不同的位置上。</li></ol><p>呼，总算是讲完了这里的逻辑，能看到这里并理解了的你真棒！<br>在这里我就不放helpTransfer方法了，只要能看懂这个，helpTransfer肯定也不在话下。</p><h3 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h3><p>get方法对比上面的那些，真是显得娇小可爱，容易理解。</p><pre><code class="highlight java"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;       Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="keyword">int</span> n, eh; K ek;       <span class="keyword">int</span> h = spread(key.hashCode());       <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;           (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123;           <span class="comment">// 如果头节点就是我们要找的，直接返回</span>           <span class="keyword">if</span> ((eh = e.hash) == h) &#123;               <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))                   <span class="keyword">return</span> e.val;           &#125;           <span class="comment">// 如果头节点的hash值为负数，说明，要么在扩容，要么是红黑树。</span>           <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)               <span class="keyword">return</span> (p = e.find(h, key)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;           <span class="comment">// 遍历链表查找</span>           <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123;               <span class="keyword">if</span> (e.hash == h &amp;&amp;                   ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek))))                   <span class="keyword">return</span> e.val;           &#125;       &#125;       <span class="keyword">return</span> <span class="keyword">null</span>;   &#125;</code></pre><p>由于比较好理解，就没写太多注释。</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>鉴于文章篇幅的原因，就不写总结了，该写的，都已经写的很详细了。其实CHM1.8的代码也不算复杂，但是其设计之精巧，真的让人佩服不已，Doug Lea大神是真的厉害。</p><p>以上，是关于ConcurrentHashMap1.8的全部内容。</p><p><strong>谢谢各位的观看。本人才疏学浅，如有错误之处，欢迎指正，共同进步。</strong></p>]]></content>
      
      
      <categories>
          
          <category> Java集合 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java集合 </tag>
            
            <tag> Java并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArrayList源码解析</title>
      <link href="2019/04/18/arraylist-yuan-ma-jie-xi/"/>
      <url>2019/04/18/arraylist-yuan-ma-jie-xi/</url>
      
        <content type="html"><![CDATA[<p>一直以来都是看别人的博客，所以从来都是输入，没有输出。所以决心自己搞一个博客输出一下学习的东西。</p><p>既然决定要写，就先从集合类开始。集合类最常用到的肯定是list，map，和set等。因此决定先从list的ArrayList写起。ArrayList的源码还是很容易理解的不算很绕。</p><p><strong>注：虽然是源码解析，但是并不是所有的源码都会涉及到，只涉及到经常使用的那些。</strong></p><p><strong>源码基于1.8。</strong></p><p>首先看看ArrayList的类关系图，了解一下它的继承关系和实现的接口。<br><img src="https://img-blog.csdnimg.cn/20190418110130389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1JlYmVsSGVybw==,size_16,color_FFFFFF,t_70" alt="ArrayList类关系图"><br>从图中可以看出，ArrayList继承自AbstractList，同时实现了克隆，序列化，随机访问这几个接口。这里不多说。</p><p>那么再来看看ArrayList拥有的变量。</p><pre><code class="highlight java"><span class="comment">// 默认的初始化容量。</span>   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;   <span class="comment">// 一个共享的空数组，用于空实例。</span>   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;   <span class="comment">// 也是共享的空数组实例，用于默认大小的空实例。</span>   <span class="comment">// 与上面的那个区别是知道添加第一个元素时会膨胀多少。</span>   <span class="comment">// 在空的构造函数中使用了。</span>   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;    <span class="comment">// 真正存放元素的数组。</span>   <span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span> <span class="comment">// ArrayList的大小。</span>   <span class="keyword">private</span> <span class="keyword">int</span> size;    <span class="comment">// 分配给数组的最大容量。</span>   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</code></pre><p>从上面的变量可以看出，该ArrayList基于数组实现的（不过这应该众所周知吧），该数组是一个<strong>动态数组</strong>。</p><p>下面看看ArrayList的构造方法：</p><pre><code class="highlight java"><span class="comment">// 用户使用带参的构造函数，指定该数组的容量。</span>  <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;  <span class="comment">// 参数大于0时， 构造该大小的数组</span>  <span class="comment">// 注意这里并没有修改size， 因为此时数组中还没有任何元素。</span>      <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;          <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;      <span class="comment">// 如果容量为0， 直接将EMPTY_ELEMENTDATA赋值给elementData</span>          <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;      &#125; <span class="keyword">else</span> &#123;      <span class="comment">// 容量小于0， 抛出异常</span>          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Capacity: &quot;</span>+                                             initialCapacity);      &#125;  &#125;  <span class="comment">// 默认的构造方法，将DEFAULTCAPACITY_EMPTY_ELEMENTDATA这个空数组赋给了elementData</span>  <span class="comment">// 其实看后面代码可以知道，如果数组是这个类型的，添加第一个元素时，ArrayList的大小会设为10</span>  <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;      <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;  &#125;  <span class="comment">/**</span><span class="comment">   * 使用其他集合类来构造ArrayList</span><span class="comment">   */</span>  <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;  <span class="comment">// 使用Collection.toArray()</span>      elementData = c.toArray();      <span class="comment">// 如果该Collection的大小不为0</span>      <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;          <span class="comment">// c.toArray 可能不是Object[]，因此使用Arrays.copyOf复制</span>          <span class="keyword">if</span> (elementData.getClass() != Object[].class)              elementData = Arrays.copyOf(elementData, size, Object[].class);      &#125; <span class="keyword">else</span> &#123;          <span class="comment">// 否则，collection 的大小为0，那么使用EMPTY_ELEMENTDATA赋给elementData</span>          <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;      &#125;  &#125;</code></pre><p>根据上面的构造函数可以看出，ArrayList提供了三种构造函数给提供给我们使用。<br>1.第一个是无参的，它会创建一个空数组。其实这样是默认大小为10的，看后面的代码可以知道。<br>2.第二个是用户指定参数的，会创建相应大小的数组，如果指定的参数是负数，那么抛出参数异常的错误。<br>3.第三个是Collection的类型，因为ArrayList继承自AbstractList，而AbstractList实现的是Collection的接口。<br>而Collection接口中提供了toArray()，因此只要是实现了Collection或其子接口的就能转换成数组。</p><p>下面继续看其他的代码：</p><pre><code class="highlight java"><span class="comment">// 该方法用来修剪大小的，因为不是所有数组中的空间都能用到。</span><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">()</span> </span>&#123;        modCount++;       <span class="comment">// 如果当前ArrayList拥有的元素小于elementData的大小。</span>       <span class="keyword">if</span> (size &lt; elementData.length) &#123;       <span class="comment">// 如果size是0，则将EMPTY_ELEMENTDATA赋给elementData，否则使用Arrays.copyOf复制</span>           elementData = (size == <span class="number">0</span>)             ? EMPTY_ELEMENTDATA             : Arrays.copyOf(elementData, size);       &#125;   &#125;      <span class="comment">// 增加ArrayList实例容量，必要时，确保它至少能容纳多少元素</span>   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;       <span class="keyword">int</span> minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)           ? <span class="number">0</span> : DEFAULT_CAPACITY;       <span class="keyword">if</span> (minCapacity &gt; minExpand) &#123;       <span class="comment">// 调用下面的方法</span>           ensureExplicitCapacity(minCapacity);       &#125;   &#125;   <span class="comment">// 如果elementData是默认的数组，那么判断默认的初始化大小（10）和参数minCapacity哪个大，然后返回。</span>   <span class="comment">// 否则直接返回minCapacity</span><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;       <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;           <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);       &#125;       <span class="keyword">return</span> minCapacity;   &#125;   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;       ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));   &#125;      <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;       modCount++;       <span class="comment">// 如果该值大于当前数组的大小，那么扩容，grow()方法就是扩容，等会再讲。</span>       <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)           grow(minCapacity);   &#125;</code></pre><p>这里引出了一个新的变量，modCount，该变量是AbstractList中protected类型的变量，ArrayList继承了这个变量。该变量的<strong>作用是</strong>：记录该ArrayList结构的变化次数，常用于迭代判断fail-fast的，一旦触发fail-fast就会抛出ConcurrentModificationException异常。关于fail-fast我这里不赘述，想了解的自行百度，可能以后也会写关于这个的文章。</p><h2 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h2><h3 id="增"><a href="#增" class="headerlink" title="增"></a>增</h3><pre><code class="highlight java"><span class="comment">// 增加一个元素。</span><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;<span class="comment">// 添加元素的时候判断，这里方法是上面的那个方法套方法，没写注释的那个</span><span class="comment">// 这里就可以知道，如果用户使用的是无参构造函数，那么默认的初始化大小是10</span><span class="comment">// 这里会使用到扩容，因此就放在一块写了。PS：这里的官方注释好可爱，我就没删了。</span>       ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span>       elementData[size++] = e;       <span class="keyword">return</span> <span class="keyword">true</span>;   &#125;   <span class="comment">// 扩容的方法。</span>   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;       <span class="comment">// 获取当前数组的大小。</span>       <span class="keyword">int</span> oldCapacity = elementData.length;       <span class="comment">// 新的大小，为旧的大小的1.5倍。</span>       <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);       <span class="comment">// 如果新的大小还是小于传来的参数，那么新的大小设为传来的参数。</span>       <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)           newCapacity = minCapacity;       <span class="comment">// 如果新的大小大于MAX_ARRAY_SIZE(变量那块有，值为Integer.MAX_VALUE - 8)</span>       <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)       <span class="comment">//下面贴出该方法。注意此时传的参数是minCapacity。</span>           newCapacity = hugeCapacity(minCapacity);       <span class="comment">// 将之前数组中的元素复制到新数组中去。</span>       elementData = Arrays.copyOf(elementData, newCapacity);   &#125;   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;   <span class="comment">// 如果minCapacity 小于零，抛出OOM错误。</span>       <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span>           <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();       <span class="comment">// 如果minCapacity 大于MAX_ARRAY_SIZE就将数组大小设为Integer.MAX_VALUE， </span>       <span class="comment">// 否则设为MAX_ARRAY_SIZE。</span>       <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?           Integer.MAX_VALUE :           MAX_ARRAY_SIZE;   &#125;</code></pre><p>这里其实还是比较好理解的。添加一个元素到ArrayList数组的末尾。当然在添加之前会判断是否需要扩容，因此，如果使用的是无参的构造函数创建对象，会默认扩展为大小为10的数组。同时可得，ArrayList扩容是扩容至原数组大小的1.5倍。</p><h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><pre><code class="highlight java">  <span class="comment">// 根据位置移除元素，返回删除的那个元素值，会抛出IndexOutOfBoundsException </span>  <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;  <span class="comment">// 这个方法是检查index是否大于size，如果大于就会抛异常。</span>      rangeCheck(index);      modCount++;      <span class="comment">// 拿到index位置上的元素</span>      E oldValue = elementData(index);<span class="comment">// 下面的操作就是将这个位置后面的元素向前移动。</span>      <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;      <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)          System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,                           numMoved);      elementData[--size] = <span class="keyword">null</span>; <span class="comment">// 设为null帮助GC(垃圾回收)</span>      <span class="keyword">return</span> oldValue;  &#125;  <span class="comment">// 根据元素移除元素</span>  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;  <span class="comment">// 如果该元素为null，那么删除list中为null元素。</span>      <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;          <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)              <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;                  fastRemove(index);                  <span class="keyword">return</span> <span class="keyword">true</span>;              &#125;      &#125; <span class="keyword">else</span> &#123;      <span class="comment">// 不为 null，则遍历数组，查找出与该元素相等的元素。</span>          <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)              <span class="keyword">if</span> (o.equals(elementData[index])) &#123;                  fastRemove(index);                  <span class="keyword">return</span> <span class="keyword">true</span>;              &#125;      &#125;      <span class="comment">// 如果该元素在数组中找不到则返回false.</span>      <span class="keyword">return</span> <span class="keyword">false</span>;  &#125;  <span class="comment">// 这是私有方法，跳过了边界检查，而且也不用返回被删除的元素</span>  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;      modCount++;      <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;      <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)          System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,                           numMoved);      elementData[--size] = <span class="keyword">null</span>; <span class="comment">// 设为null帮助GC</span>  &#125; <span class="comment">// 清除所有的元素。</span>  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;      modCount++;      <span class="comment">// 帮助GC</span>      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)          elementData[i] = <span class="keyword">null</span>;      size = <span class="number">0</span>;  &#125;</code></pre><p>从这里可以看出， <strong><em>ArrayList是支持插入null数据的</em></strong>。删除元素一般根据index或者根据元素来删除，但是<strong>需要注意的是：</strong>根据元素来删除只会删除第一次出现的位置，之后即使还有这个元素，也还是不会删除的。</p><h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><pre><code class="highlight java"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;<span class="comment">// 越界检查</span>    rangeCheck(index);    <span class="comment">// 根据下标取出数据</span>    <span class="keyword">return</span> elementData(index); &#125;<span class="function">E <span class="title">elementData</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;    <span class="keyword">return</span> (E) elementData[index];&#125;</code></pre><h3 id="改"><a href="#改" class="headerlink" title="改"></a>改</h3><pre><code class="highlight java"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;       rangeCheck(index);<span class="comment">// 根据index拿到之前旧数据。</span>       E oldValue = elementData(index);       <span class="comment">// 将改位置上的数据设为你传入的数据。</span>       elementData[index] = element;       <span class="keyword">return</span> oldValue;   &#125;</code></pre><p>查和改都很一目了然，就不多说了。</p><p>还有一个也比较常用，判断该元素在ArrayList中是否存在：</p><pre><code class="highlight java"><span class="comment">// 判断元素在ArrayList中是否存在。</span><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;       <span class="keyword">return</span> indexOf(o) &gt;= <span class="number">0</span>;   &#125;   <span class="comment">// 如果元素在ArrayList中，那么返回该元素第一次出现的位置。否则返回-1。</span>   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;       <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)               <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)                   <span class="keyword">return</span> i;       &#125; <span class="keyword">else</span> &#123;           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)               <span class="keyword">if</span> (o.equals(elementData[i]))                   <span class="keyword">return</span> i;       &#125;       <span class="keyword">return</span> -<span class="number">1</span>;   &#125;   <span class="comment">// 与之相对应的是lastIndexOf，这样会从后面开始查找元素，返回元素最后一次出现的位置，否则返回-1</span><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> </span>&#123;       <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;           <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)               <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)                   <span class="keyword">return</span> i;       &#125; <span class="keyword">else</span> &#123;           <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)               <span class="keyword">if</span> (o.equals(elementData[i]))                   <span class="keyword">return</span> i;       &#125;       <span class="keyword">return</span> -<span class="number">1</span>;   &#125;</code></pre><p>indexOf和lastIndexOf在String类中也有。</p><p>这里我踩过一个很小的坑，也说一下吧，不过只是我想当然的原因。当时需要做判断，如果字符串中有=，就截取部分字符串然后跳转，没有就跳另外一个。于是使用indexOf来查找=，返回=在字符串中的位置，由于并不是每个传来的字符串都会有=，因此就会返回-1。但是我没判断这个-1，直接就截取了，因此不管怎样都是跳一个页面。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>首先，ArrayList基于动态数组。因此在增删改查的操作中，<strong>增和删的效率都比较低</strong>，因为增可以会导致扩容，而删需要移动元素，除非移动的是最后一个元素，**<em>同时也会修改modCount这个值**</em>。<strong>查和改效率都是比较高的</strong>，因为直接定位修改和取出。</li><li>ArrayList是线程不安全的，多个线程同时的操作的话，建议使用Collections.synchronizedList()封装，或者在外部使用锁，如果读操作远高于写操作的话，那么建议使用CopyOnWriteArrayList。</li><li>这里再提一下，ArrayList和Vector的区别，因为不会写Vector相关的文章，因此这里就直接说了吧。Vector也是基于数组的，与ArrayList不同，Vector是线程安全的，但是是因为它每个方法都使用sychronized修饰，每次只允许一个线程进行操作，因此效率很低。然后，Vector每次都是两倍扩容，ArrayList则是1.5倍扩容的，也是不一样的区别之处。</li></ul><p>最后，以上是关于ArrayList的全部内容。</p><p><strong>谢谢各位的观看。本人才疏学浅，如有错误之处，欢迎指正，共同进步。</strong></p>]]></content>
      
      
      <categories>
          
          <category> Java集合 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>偏向锁、轻量级锁，重量级锁膨胀过程</title>
      <link href="2018/12/27/pian-xiang-suo-qing-liang-ji-suo-chong-liang-ji-suo-peng-zhang-guo-cheng/"/>
      <url>2018/12/27/pian-xiang-suo-qing-liang-ji-suo-chong-liang-ji-suo-peng-zhang-guo-cheng/</url>
      
        <content type="html"><![CDATA[<p>在JDK 1.6之前，synchonized同步方式的成本非常高，因为使用了系统调用引起的内核态与用户态切换、线程阻塞造成的线程切换等。但是后面改进了，引进了锁的四个状态，分别是无锁，偏向锁，轻量级锁，重量级锁，而且是只能逐级膨胀的。</p><p>但是我刚接触的时候一直很纠结膨胀过程，后来搞明白了，现在抽个时间总结记录一下。</p><p>首先我们要知道，这几个级别适用的情况。</p><ul><li>偏向锁：适用于只有一个线程进入同步区</li><li>轻量级锁：适用于多个线程交替进入同步区</li><li>重量级锁：适用于多个线程同时竞争进入同步区</li></ul><p>这里我就不赘述有关它们三个的具体，直接讲解如何膨胀。</p><ol><li><p>当一个线程（假设叫A线程）想要获得锁时，首先检查对象头中的锁标志，如果是偏向锁，则跳转到2，如果是无锁状态，则跳转到3.</p></li><li><p>检查对象头中的偏向线程id是否指向A线程，是，则直接执行同步代码块，不是则3.</p></li><li><p>使用cas操作将替换对象头中的偏向线程id，成功，则直接执行同步代码块。失败则说明其他的线程（假设叫B线程）已经拥有偏向锁了，那么进行偏向锁的撤销（因为这里有竞争了），此时执行4.</p></li><li><p>B线程运行到全局安全点后，暂停该线程，检查它的状态，如果处于不活动或者已经退出同步代码块则原持有偏向锁的线程释放锁，然后A再次执行3。如果仍处于活动状态，则需要升级为轻量级锁，此时执行5.</p></li><li><p>在B线程的栈中分配锁记录，拷贝对象头中的MarkWord到锁记录中，然后将MarkWord改为指向B线程，同时将对象头中的锁标志信息改为轻量级锁的00，然后唤醒B线程，也就是从安全点处继续执行。</p></li><li><p>由于锁升级为轻量级锁，A线程也进行相同的操作，即，在A线程的栈中分配锁记录，拷贝对象头中的Mark Word到锁记录中，然后使用cas操作替换MarkWord，因为此时B线程拥有锁，因此，A线程自旋。如果自旋一定次数内成功获得锁，那么A线程获得轻量级锁，执行同步代码块。若自旋后仍未获得锁，A升级为重量级锁，将对象头中的锁标志信息改为重量级的10，同时阻塞，此时请看7.</p></li><li><p>B线程在释放锁的时候，使用cas将MarkWord中的信息替换，成功，则表示无竞争（这个时候还是轻量级锁，A线程可能正在自旋中）直接释放。失败（因为这个时候锁已经膨胀），那么释放之后唤醒被挂起的线程（在这个例子中，也就是A）。</p><p>以上就是我理解的锁膨胀过程。有错误的地方，欢迎指正。</p></li></ol><p>这里补充一些<strong>额外的知识</strong>：</p><p><strong>自旋锁</strong>，也就是如果持有锁的线程能很短时间内释放锁，那么竞争锁的线程就不需要进入阻塞挂起状态，而是等一会（自旋），这样能避免用户线程和内核线程的切换消耗，但是如果超过一定时间仍未得到，还是会进入阻塞。</p><p>通过自旋锁，可以减少线程阻塞造成的线程切换（包括挂起线程和恢复线程）。<br>1.6之后引入了<strong>自适应自旋锁</strong>，是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。</p><p><strong>自适应自旋解决的是“锁竞争时间不确定”的问题</strong>。JVM很难感知到确切的锁竞争时间，而交给用户分析就违反了JVM的设计初衷。自适应自旋假定不同线程持有同一个锁对象的时间基本相当，竞争程度趋于稳定，因此，可以根据上一次自旋的时间与结果调整下一次自旋的时间。</p><p> <strong>各个锁适用的场景：</strong></p><p>这里我使用一下《java并发编程艺术》中的总结</p><table><thead><tr><th>锁</th><th>优点</th><th>缺点</th><th>使用场景</th></tr></thead><tbody><tr><td>偏向锁</td><td>加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距</td><td>如果线程间存在锁竞争，会带来额外的锁撤销的消耗</td><td>适用于只有一个线程访问同步块场景</td></tr><tr><td>轻量级锁</td><td>竞争的线程不会阻塞，提高了程序的响应速度</td><td>如果始终得不到锁竞争的线程使用自旋会消耗CPU</td><td>追求响应时间,锁占用时间很短</td></tr><tr><td>重量级锁</td><td>线程竞争不使用自旋，不会消耗CPU</td><td>线程阻塞，响应时间缓慢</td><td>追求吞吐量,锁占用时间较长</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 锁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 锁 </tag>
            
            <tag> Java并发 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
